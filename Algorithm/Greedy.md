# Greedy Algorithm

## 개요

알고리즘이라고 하면 공식이 떠오른다. 값을 딱 넣으면 알아서 답을 내주는 수학의 수식과 같은 느낌이다.

그러나 알고리즘을 공부하다보면 경험적인 문제 풀이도 존재한다. 대표적으로 탐색 알고리즘이 있다.

그리디 알고리즘은 탐욕법이라고도 하며 문제를 단순무식하게 탐욕적으로 푼다고 해서 탐욕법이라는 이름이 붙었다.

> 현재 상황에서 최선의 선택을 한다.

## 설명

그리디 알고리즘을 가장 쉽게 설명할 수 있는 방법은 바로 거스름돈 문제다.

예를 들어 내가 500원, 100원, 50원, 10원짜리 동전을 가지고 있고 충분히 여유있는 갯수로 가지고 있다. 동전 갯수를 최소한으로 써서 넘치지도 않게 부족하지도 않게 정확히 일정 금액을 지불하려고 한다면 어떻게 하는 게 좋을까?

예를 들어 가게에서 3420원을 지불하려한다. 내가 가진 동전은 1원 10원 50원 100원 500원이 있다고 했을 때 동전 갯수를 최소한으로 쓰려면 일단 가장 큰 금액으로 지불할 수 있을 만큼 지불해야한다.

500원이 내가 가진 가장 큰 금액의 동전이므로 500원동전으로만 쓰는게 가장 적게 동전을 쓰는 방법일 것이다.
그러나 500원을 6개 쓰면 부족하고 7개를 쓰면 넘친다.

그러면 500원짜리 동전 6개를 쓰고 그 다음 작은 단위로 넘어가야한다. 그리고도 남으면 더 작은단위로.

이러한 방식을 그리디 알고리즘이라고 한다.
현재 상태에서 보는 선택지중 최선을 선택하고 그 다음 상황에서 또 최선을 선택한다. 그리고 각 상황에서의 최선이 전체의 최선이여야한다.(그리디 알고리즘을 사용할 수 있는 조건)

문제를 푸는 방법은 이렇다. 3420원을 내가 가진 가장 큰 금액의 동전으로 나눈다.
이 경우 6개가 되겠다. 남은 금액은 420원이다.
그 다음은 100원짜리 4개를 쓰고 그 다음은 10원짜리 동전 2개를 쓴다.
이렇게한다면 최소한의 동전만 쓸 수 있다.

의사코드로 표현한다면 다음과 같다.
```java
for(오름차순으로 정렬된 동전 액수의 인덱스를 거꾸로 반복) {
    if(지불 금액보다 동전의 금액이 작으면) {
        동전 수 += 목표금액 / 현재 동전의 금액
        총 금액 = 목표금액 % 현재 동전의 금액.
    }
}
```

코드를 보면 반복문을 돌릴 때 1개의 반복문을 돌리고 있으니 시간복잡도는 O(n)이고 시간 복잡도에 영향을 주는 요소는 금액이 아니라 동전의 종류다.

## 주의점

효과적이고 강력한 알고리즘이지만 모든 문제에 그리디알고리즘을 적용할 수 있는 것은 아니다.

예를 들어 항상 지금 상황에서의 최선을 선택했지만 최적의 해를 찾을 수 없을 수 있다.

따라서 그리디 알고리즘을 사용할 수 있는 조건은 각 상황에서 최적의 해를 찾는 것이 결과적으로 최적의 해를 구하는 것이라는 보장이 있어야한다.

예를 들어 화폐단위가 500원, 400원, 100원이 있고 이를 이용해서 800원을 내야하는 문제가 있다고 해보자.

그리디 알고리즘을 적용한다면 500원을 지불할 것이고 남은 금액인 300원을 100원짜리 3개로 지불할 것이다. 이러면 매 상황에서 최선을 선택한 것이니 정답일 것 같지만 최적의 해는 400원짜리 동전 2개를 내는 것이다.

만약 알고리즘 문제를 푸는데 해결방법이 쉽게 떠오르지 않는다면 그리디알고리즘을 의심해보는 것이 좋다. 만약 이 것도 아니라면 동적 계획법이나 그래프 알고리즘일 확률이 높다.

## 문제풀이

### 큰 수의 법칙

#### 문제 이해하기

* 다양한 수로 이루어진 배열이 있다.
* 주어진 수를 M번 더하여 가장 큰 수를 만들어야한다.
* 배열의 번호 해당하는 수가 연속해서 k번을 초과하여 더해질 수 없다.
* 첫째 줄에 N, M, K가 주어진다.
* 큰수의 법칙에 따른 결과를 출력해라.

입출력 예시
```py
# 입력
5 8 3
2 4 5 4 6
# 출력
46
```

제시된 수의 갯수는 5개고 총 8번을 더해야하고 같은 숫자는 3번을 넘지 않아야한다.

문제의 조건에 맞춰 가장 큰 수를 만들면 이렇다.  
`6+6+6+5+6+6+6+5 = 46`

`6+6+6+5, 6+6+6+5`

만약 반복할 수 있는 최대 횟수가 3이라면 4개의 숫자를 연산하는 부분이 반복된다.  
이렇다면 반복문을 돌릴 것이 아니라 나눗셈으로 적절하게 계산한 뒤 각 숫자가 등장하는 횟수를 구해서 곱해주면된다.

4라는 숫자는 `k+1`로 정리된다.  
따라서 `m`을 `(k+1)`로 나눈 몫이 반복되는 횟수가 된다.  
예를 들어 8번의 연산이라고 하면 4개의 숫자가 8을 4로 나눈 몫만큼 반복된다.
그리디 알고리즘의 성격을 살려서 일반화 시켜보자면 이렇다.

총 횟수는 `m`으로 `m / (k+1) * k`를 하면 가장 큰 수가 더해지는 횟수가 나오고

그럼 첫 번째 수의 합은 `(first * k) * m/(k+1)` 를 해주면 되고 두 번째로 큰 수를 더하는 부분은 `(m - count) * second`가 된다.  
그러나 지금은 예제 입출력에서는 숫자 패턴의 주기와 딱 떨어지는 `m`이 주어졌지만 나누어 떨어지지 않는 수가 주어질 수도 있다.
예를 들어 `m = 9`일 경우 우리가 구한 식은 들어맞지 않게된다.  
```
9 / 4 * 3 = 6
```
이렇게 6이라는 값이 나오지만 직접 손으로 풀어보면 `6+6+6+5 + 6+6+6+5 + 6`으로 실제 횟수는 7번이므로 답이 틀리게된다.
이를 보정하기 위해 가장 큰 수가 더해지는 횟수를 구한 다음 `k+1`로 나눈 나머지를 구해서 더해주면 된다.  

```py
count = m / (k+1) * k + m % (k+1) 
result += (first) * (m / (k+1)) * k  # 위에서 정리한 식
result += m 
```

여기에 다시`k`를 곱해주면 가장 큰 수가 등장하는 횟수가 된다.



#### 의사 코드

```py
n(숫자의 갯수), m(연산 횟수), k(연속해서 더할 수 있는 횟수) = 입력받기
n개의 수를 담을 리스트

리스트 정렬
가장 큰 수 = 리스트[n-1]
두 번째로 큰 수 = 리스트[n-2]

가장 큰 수가 더해지는 횟수 계산
result += (count) * first
result += (m - count) * second
```

#### 최종 코드
```py
import sys

input = sys.stdin.readline
n, m, k = map(int, input().split())
data = list(map(int, input().split()))
result = 0

data.sort(reverse=True)
first = data[0]
second = data[1]

count = int(m / (k+1)) * k
count +=  m % (k+1) 

result += count * first
result += (m - count) * second

print(result)
```

### 숫자 카드 게임

#### 문제 이해하기

* 가장 높은 숫자가 쓰인 카드 한 장을 뽑는 게임이다.
* 여러 개의 카드 중에서 가장 높은 숫자가 쓰인 카드 한 장을 뽑는다.
* 숫자가 쓰인 카드가 n * m의 형태로 있고 먼저 뽑으려는 카드가 포함되어있는 행을 선택한다.
* 선택된 행에 포함된 카드들 중 가장 숫자가 낮은 카드를 뽑아야한다.
* 따라서 처음 카드를 뽑을 행을 선택할 때 이후 해당 행에서 가장 숫자가 낮은 카드를 뽑을 것을 고려하여 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 한다.

예를 들어 3*3 형태의 카드 배열이 주어졌다.  
```
3 1 2
4 1 4
2 2 2 
```

첫 번째 행에 있는 가장 큰 수의 카드를 선택하면 답은 1, 두번 째 행도 1, 세 번째 행은 2로 세번째 행의 카드를 선택해야한다.

입출력은 다음과 같다.
```
3 3
3 1 2
4 1 4
2 2 2 
```

#### 손으로 풀기

```py
n, m 입력받기
출력할 결괏값

n만큼 반복:
    리스트 = 한 줄씩 입력받기
    최솟 값 = min(입력받은 라인)
    결괏값 = max(결괏값, 가장 작은 수)

출력하기
```
#### 최종코드

```py
import sys

input = sys.stdin.readline
n, m = map(int, input().split())
result = 0

for i in range(n):
    data = list(map(int, input().split()))
    min = min(data)
    # 이전에 갱신된 result값과 입력받은 라인의 최솟값을 비교하여 재갱신
    result = max(result, min)

print(result)
```

### 체육복

#### 문제 이해하기
```
점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다.

전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요.
```

* 전체 학생의 수는 2명 이상 30명 이하입니다.
* 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.
* 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.
* 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다.
* 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은
* 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.

**입출력**
```
n	lost	reserve	
5	[2, 4]	[1, 3, 5]
5	[2, 4]	[3]
3	[3]	[1]	

5
4
2
```

n은 학생의 수, lost는 체육복을 잃어버린 학생의 번호, reserve는 여분의 체육복을 가지고있는 학생의 번호이다.

1번 학생은 여분의 체육복을 가지고 있으니 2번 학생에게 줄 수 있고 3번 학생은 4번에 빌려주면 총 5명의 학생이 체육복을 입을 수 있다.

바로 왼쪽, 오른쪽에 있는 학생에게만 빌려줄 수 있으므로 최선의 해는 반복문을 돌며 인접한 번호의 학생이 체육복을 가지고있지 않으면 빌려주는 식으로 코드를 작성하면 된다. 

그리디 알고리즘으로 풀면 현재 상황에서의 최선이 전체에서의 최선이 되어야한다.
어떻게 하면 현재의 해가 전체의 해가 될 수 있을까?

만약 이전 번호의 학생이 체육복을 가져오지 않았다고 해보자. 그렇다면 이전 번호의 학생은 그 이전 번호의 학생에게 체육복을 받지 못한 상태라고 할 수 있다. 그렇다면 내 다음 번호의 학생이 체육복이 없다고 하더라도 그 다음 학생에게 체육복을 받을 수 있는 가능성이 있지만 내 이전 번호의 학생은 내가 빌려주는 것이 아니면 받을 수 없게된다.

따라서 앙 옆의 학생 모두가 체육복을 가지고오지 않았다면 왼쪽의 학생에게 빌려주는 것이 최선의 해가 된다.

그리고 문제의 마지막에 체육복을 가져온 학생도 체육복을 도난당했을 수 있다고 하니 전처리 작업을 해주어야한다.

reserve에서 lost를 빼야하고 이렇게 되면 여유 체육복이 없는 것이 되니 lost도 갱신해주어야한다.



#### 손으로 풀어보기

```
전처리 작업

반복문 (1, n+1):
    
```


