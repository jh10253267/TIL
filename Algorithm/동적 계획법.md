# 동적 계획법

## 개요
모든 알고리즘 문들은 완전탐색으로 해결할 수 있다.
그러나 비효율적인 연산과 시간을 줄이기 위해 여러 알고리즘이 있는데 동적 계획법이란 그 중 가장 많은 문제를 효율적으로 풀 수 있는 알고리즘이다.
동적 계획법이란 복잡한 문제를 여러개의 간단한 문제로 분리하여 부분의 문제들을 해결함으로써 최종적으로 복잡한 문제의 답을 구하는 방법이다.

## 핵심 이론
동적 계획법의 원리와 구현 방식은 이러하다.
 * 큰 문제를 작은 문제로 쪼갤 수 있어야한다.
 * 작은 문제들이 반복되어 나타난다
 * 이 작은 문제들의 결과값은 항상 같아야한다.
 * 작은 문제들은 한 번만 계산해 DP테이블에 저장하며 추후 재사용할 때는 이 테이블의 값을 이용한다.
 * 동적 계획법은 톱다운과 바텀업 방식으로 구현한다.

## 예시 문제

### 파보나치 수열
5번 째 피보나치 수열은 4번째 피보나치 수열과 3번째 피보나치 수열의 합이다.
즉 5번 째 피보나치 수열의 값은 4번째, 3번째 수열을 구하는 작은 문제로 
쪼갤 수 있고 수열의 값은 항상 같기에 동적 계획법으로 풀 수 있다.

점화식을 세워보면 D[i] = D[i-1] + D[i-2]가 된다.
그 다음 이 값을 DP테이블에 저장해놓는다.
만약 해당 값이 필요하면 다시 연산하지 않고 저장되어있는 값을 사용한다.

### 정수를 1로 만들기
정수 n개가 주어졌을 때 
* 3으로 나누어 떨어지면 3으로 나눈다.
* 2로 나누어 떨어지면 2로 나눈다.
* 1을 뺀다.

#### 문제 플이 과정
D[i]는 i에서 1로 만드는데 걸리는 최소 연산 횟수<br>
D[i] = D[i-1] + 1<br>
if(i % 2 == 0) min(D[i], D[i]/2 + 1)<br>
if(i % 3 == 0) min(D[i], D[i]/3 + 1)<br>


#### 의사코드
```java
N은 구하고자 하는 수
for(i -> 2 ~ N) {
  D[i] = D[i-1] + 1
  if(i % 2 == 0) min(D[i], D[i]/2 + 1) // 결과가 D[i]보다 작으면 변경하기
  if(i % 3 == 0) min(D[i], D[i]/3 + 1) // 결과가 D[i]보다 작으면 변경하기 
}
```


