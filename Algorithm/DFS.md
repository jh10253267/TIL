# DFS

## 개요

DFS는 깊이 우선 탐색을 말한다. 이는 그래프 완전 탐색 기법중 하나로 시작 노드에서 출발하여 한쪽 분기를 정하여 최대 깊이까지 탐색을 마친 후 다른 쪽 분기로 이동하여 다시 탐색을 수행하는 알고리즘이다.

깊이 우선 탐색은 재귀 함수를 이용해서 구현할 수 있다.


## 설명

예를 들어 다음과 같은 그래프가 있다고 해보자.
```
1->2->5
|   ㄴ>6
3->4->6 
```

이를 깊이 우선 탐색을 시작하면 탐색 순서는 다음과 같다.

시작을 1번 노드로 시작하고 이를 스택에 삽입한다.

스택에서 꺼낸 뒤 인접 노드를 다시 스택에 삽입한다.

1의 인접 노드는 2와 3이다.

스택에는 2, 3의 순서로 들어간다.

그리고 방문 리스트에 이를 기록한다.
그런 가장 위의 값인 3을 꺼낸다. 3의 인접 노드는 4이므로 4를 스택에 넣고 뺀 뒤 방문 리스트에 기록한다.

방문 리스트에는 1,2,3,4가 체크되어있다.

그런 뒤 다시 4의 인접 노드인 6을 넣고 위의 과정을 반복한다.

그럼 스택에 남아있는 값은 2다.

2의 인접 노드는 5, 6이고 6은 이미 방문했으니 삽입하지 않는다.

이렇게 되면 5가 스택에 들어갔다가 나온다.

이렇게 DFS가 끝났다.  
방문 순서는 1,3,4,6,2,5가된다.

## 문제풀이

연결 요소의 갯수 구하기

대충 노드의 번호와 인접한 노드 번호를 제공해주고 연결 요소의 갯수를 구하라는 문제이다.

연결 요소의 갯수는 만약 모든 요소들이 이어져있다면 1이 될 것이고 메인에서 시작하여 노드가 2개로 갈린다면 2가 될 것이다.

```
첫째 줄에 정점의 개수 N과 간선의 개수 M이 주어진다. (1 ≤ N ≤ 1,000, 0 ≤ M ≤ N×(N-1)/2) 둘째 줄부터 M개의 줄에 간선의 양 끝점 u와 v가 주어진다. (1 ≤ u, v ≤ N, u ≠ v) 같은 간선은 한 번만 주어진다.
```

```
첫째 줄에 연결 요소의 개수를 출력한다.
```

의사코드
```
n(노드 개수) m(엣지 개수)
A(그래프 데이터 저장 인접 리스트)초기화
visited(방문 기록 리스트) 초기화

DFS:
  visited 리스트에 현재 노드 방문 기록
  현재 노드의 연결 노드 중 방문하지 않은 노드로 DFS실행

for m의 개수만큼 반복:
    A 인접 리스트에 그래프 데이터 저장

for n의 개수만큼 반복:
  if 방문하지 않은 노드가 있으면:
    연결 요소 개수 값 1 증가
    DFS실행

연결 요소 개수 값 출력
```

풀이 코드
```python
import sys
sys.setrecursionlimit(10000)
input = sys.stdin.readline
n, m = map(int, input().split())
A = [[] for _ in range(n+1)]
visited = [False] * (n+1)


def DFS(v):
    visited[v] = True
    for i in A[v]:
        if not visited[i]:
            DFS(i)
            
for _ in range(m):
    s, e = map(int, input().split())
    A[s].append(e)
    A[e].append(s)
    
count = 0

for i in range(1, n+1):
    if not visited[i]:
        count += 1
        DFS(i)
        
print(count)
```

```
수빈이가 세상에서 가장 좋아하는 것은 소수이고, 취미는 소수를 가지고 노는 것이다. 요즘 수빈이가 가장 관심있어 하는 소수는 7331이다.

7331은 소수인데, 신기하게도 733도 소수이고, 73도 소수이고, 7도 소수이다. 즉, 왼쪽부터 1자리, 2자리, 3자리, 4자리 수 모두 소수이다! 수빈이는 이런 숫자를 신기한 소수라고 이름 붙였다.

수빈이는 N자리의 숫자 중에서 어떤 수들이 신기한 소수인지 궁금해졌다. N이 주어졌을 때, 수빈이를 위해 N자리 신기한 소수를 모두 찾아보자.
```

```
첫째 줄에 N(1 ≤ N ≤ 8)이 주어진다.
```

```
N자리 수 중에서 신기한 소수를 오름차순으로 정렬해서 한 줄에 하나씩 출력한다.
```

소수의 조건은 1과 자기자신을 제외하고 약수가 없는 수를 말한다.

예를 들어 4라는 값이 입력되었다면 1111~9999안에서 소수를 찾으면 된다.  
이 문제는 카드를 순서대로 조합하듯이 접근해야한다.

왼쪽 부터 1의 자리라고 하면 우선 처음 숫자가 소수여야한다.

1부터 9까지의 값중에서 소수는 2, 3, 5, 7이다.

여기서부터 시작한다.

```
2 -> 1 (소수가 아니므로 탈락)
  ㄴ>3 -> 1 (탈락)
      ㄴ> 3 -> 3 (2333은 소수이다.)
3
5
7
```

이런 식으로 나타내볼 수 있다.

의사코드
```
N(입력받은 자릿수)
for i in 2~현재 수/2+1까지 반복:
    if 현재 수 % i가 0이면:
        return 소수가 아님

DFS():
    if 자릿수 == N:
        현재ㅐ수 출력
    else:
        for i를 1~9 반복:
                if i를 뒤에 붙인 수가 홀수이면서 소수일 때:
                    DFS(수 * 10 + 뒤에 붙는 수) 실행
DFS 실행(숫자 2, 3, 5, 7로 탐색 시작)
```


```python
import sys
sys,setrecursionlimit(10000)
input = sys.stdin.readline
N = int(input())

def isPrime(num):
    for i in range(2, int(num / 2 + 1)):
        if num % i == 0:
            return False
    return True

def DFS(number):
    if len(str(number)) == N:
        print(number)
    else: for i in range(1, 10):
        if i % 2 == 0:
            continue
        if isPrime(number * 10 + i):
            DFS(number * 10 + i)

DFS(2)
DFS(3)
DFS(5)
DFS(7)
```