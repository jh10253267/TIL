# 12.20

##

개념이 뒤죽박죽인 것 같다. 사람이 무언가를 배울 때 습득하기 어렵게 만드는 요소중에 하나가 일관성이 없는 것이라고 생각한다.

사용하고있는 라이브러리나 프레임워크들은 빠르게 업데이트되고 그 과정에서 내가 알던 사용법이랑은 다른 부분들이 생긴다. 또 사람들마다 코드짜는 방식이 다른 것도 그렇다.

차분히 추상적 -> 구체적으로 접근해보자.

전체적인 시나리오를 아는 게 먼저고 그 사용법은 그 다음에 시간을 들여서 익히면 되는 부분이라고 생각한다.

## 고민들

페이지네이션을 사용하는 게 더 어렵지않나 하는 생각이 들었다. 페이징 조건이 복잡해져도 결국 sql의 limit를 이용하는 것일텐데 Querydsl을 설정하는 것 부터 복잡했고 사용법은 더 복잡해보인다.

어떤 게 좋은 테스트일지 고민해봤다. 생각해본것은 당연한 얘기지만 테스트가 실제 프로덕션한 db에 영향을 미치면 테스트의 조건이 달라지기 때문에 테스트 환경을 적극 이용하는 것이 좋겠다.

어떤 개념을 사용하는게 이전보다 더 복잡하고 까다롭다면 굳이 사용해야할 필요가 있을까 생각이 들었다.

예를 들어 현실 세계와 동일하게 객체를 생성하는게 객체지향이 아니라고 들었다. 오히려 역할을 나누기 힘들어지고 유지보수의 난이도가 올라간다면 굳이 1:1로 매칭시킬 필요가 있을까 싶다.

JPA를 사용하고는 있는데 자동화된 부분은 좋지만 오히려 개발의 복잡성을 증가시키는 게 아닐까 생각이 들기도한다.

개념! 개념! 곧 죽어도 개념이다.

알고리즘의 이유와 구현방식을 안다면 시간이 조금 많이 들어 비효율적이적이더라도 스스로 구현할 수 있다고 생각한다. 

상황이 바뀌어도 구현해낼 수 있을것이다.

##

JPA를 이용하면 직접 쿼리를 작성하는 일이 드물다.

그렇기 때문에 긴 쿼리문이나 조건이 걸린 쿼리를 작성할 땐 어떻게해야하나 궁금할 수 있다.

이를 위한 개념이 쿼리메소드와 JPQL이다

쿼리 메소드는 직접 쿼리를 작성하지 않고 메소드 이름이 하나의 쿼리가 되는 기능으로 문제는 메소드 이름이 엄청나게 길어질 수 있다는 점이다.

그래서 단순한 쿼리를 작성할 때만 사용된다고하고 JPQL은 JPA의 쿼리이다. 기본적으로 SQL의 형식이지만 좀더 자바 친화적이다.

그러나 이러한 기능들로도 구현하기 힘든 부분이 있는데 바로 동적쿼리처리다.

예를 들어 검색이라는 기능에선 복합적인 조건들이 결합될 수 있다. 이는 JPQL로는 구현하기 힘든 부분이다. 각 경우의 수를 따지고 그에 맞춰 쿼리를 짜야한다.

##

Pageable과 Page<E> : 전자는 인터페이스로 설계되어있고 간단한 페이징 기능을 수행할 수 있다.
그리고 Pageable을 파라미터로 넣어서 수행한 결과물인 Page는 내부적으로 페이징 처리에 필요한 정보들을 처리한다.

