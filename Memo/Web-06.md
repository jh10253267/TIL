# Spring Data JPA

## JPA
JPA Java Persistence API의 약자이며 그 이름 그대로 자바의 영속계층을 처리하는 API라는 의미이다.
이는 ORM이라는 패러다임으로 객체 지향으로 구성한 시스템을 관계형 데이터베이스에 매핑하는 패러다임이다.
그리고 스프링 부트에선 이를 위해 JPA를 사용한다.

## Entity

### 기본 설정
JPA를 이용한 개발의 핵심은 객체지향을 통해서 영속계층을 처리하는 데 있다. 따라서 우리는 JPA를 이용할 때 직접테이블과 SQL을 다루는 것이 아니라 데이터에 해당하는 객체를 엔티티 객체라는 개념으로 다루고 JPA로 이를 데이터베이스와 연동해서 관리하게 된다.

엔티티 객체는 PK(기본키)를 가지는 자바의 객체이다. 그리고 와닿는 의미로는 엔티티 객체 하나는 RDB에서 하나의 테이블이라고 생각해도 좋다.

우선 첫 단계는 엔티티 클래스를 정의하는 것이다.

기존에 사용해봤던 VO객체처럼 클래스를 생성하고 해당 클래스에 @Entity라는 어노테이션을 붙여준다.

```java
@Entity
public class Board {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;
  private String title;
  private String content;
}
```
위와 같이 작성하면 된다.
@Entity 어노테이션을 추가하면 에러가 발생하는 것을 볼 수 있는데 이는 @Id 애노테이션이 없기 때문이다. 
앤티티 클래스는 반드시 @Entity와 @Id어노테이션을 가져야한다.
그리고@Id어노테이션이 붙은 필드가 바로 우리가 RDB를 사용할 때 해당 테이블이 가지는 PK값이다.

그리고 @GeneratedValue(strategy = GenerationType.IDENTITY) 부분은 우리가 create table 문을 사용할 때 pk값의 속성으로 넣어주는 auto_increment와 같은 의미이다.

### MappedSuperClass
하나의 튜플에는 단순히 그 정보 뿐만 아니라 메타 데이터가 들어있다. 우리가 블로그 게시글을 작성하고 나면 해당 게시글이 작성된 시각을 보여주고 작성자가 누구인지도 보여준다. 이러한 정보들을 메타 데이터라고 하는데 이를 자동화해주는 친구가
@MappedSuperClass이다. 기존의 스프링 프로젝트를 작성할 땐 일단 해당 칼럼이 있어야하고 자바에서 직접 메타데이터를 넣어줘야했지만 JPA의 기능을 이용하면 자동화 할 수 있다.

@MappedSuperClass를 이용하면 데이터 튜플이 가져야하는 공통 데이터들을 쉽게 처리할 수 있다.

## JPA Repository
JPA를 이용할 때는 JpaRepository라는 인터페이스를 이용해서 인터페이스를 선언해준 것 만으로도 기본적인 작업을 처리할 수 있다. 만약 기본 기능 외에도 커스텀해주고 싶은 부분이 있다면 메소드 이름자체가 쿼리문이 되는 쿼리 메소드라던가 Querydsl을 이용할 수 있다.

### 영속성 컨텍스트
간단하게 실습해본다면 아마 수정이나 삭제시에도 select문이 실행되는 것을 볼 수 있는데 이런 현상은 다음과 같은 이유로 일어나게된다.

JPA를 이용한다는 것은 즉 영속 컨텍스트와 데이터베이스를 동기화해서 관리한다는 의미이다.

그렇기에 특정한 엔티티 객체가 추가되면 영속 컨텍스트에 추가하고 데이터베이스와 동기화가 이루어져야한다. 수정이나 삭제도 영속 컨텍스트에 일단 해당 엔티티 객체가 존재해야하기에 먼저 select쿼리를 던져서 엔티티 객체를 영속 컨텍스트에 저장하고 이를 삭제한 뒤 delete가 이루어지는 것이다.


## 연관관계
### 개요

데이터베이스를 다뤄본 적이 있으면 관련이 있는 테이블을 어떻게 연결하는지 알고 있을것이다.

데이터베이스에서는 PK와 FK를 이용해서 테이블간의 관계를 표현하는데 일반적으론 PK를 갖는 테이블을 먼저 설계하고 이를 FK로 사용하는 테이블을 설계한다.

즉 데이터베이스의 설계에선 우선순위가 결정되고 처리방식도 일정한 규칙이 존재한다.

그러나 객체지향을 이용하는 JPA는 조금 다른데 객체지향은 우선 방향성을 결정하기가 어렵다.

예를들어 유저가 여러개의 아이템을 가지고있다고 가정하면 유저 객체가 아이템을 참조할 것인지 아이템이 유저를 참조할 것인지 정해야한다.

이는 좀 더 자주 변화가 있는 쪽을 선택하는 것이 좋다.

예를 들어 회원과 게시글이 있다면 좀더 잦은 변화가 있는 쪽은 게시글일 것이다. 우리는 이렇게 생각하곤 한다. 회원이 게시글을 작성한다. 그러나 이러한 설계는 바람직하지 않을 수 있는데 이렇게 유저를 기준으로 시작하면 엔티티가 점점 늘어나고 클래스 설계를 감당할 수 없을만큼 많은 연관관계가 필요하게 된다.
 
 ### 단방향과 양방향
 앞에서 정리한대로 유저가 게시물을 참조하거나 게시물이 유저를 참조하거나 할 수 있다. 이런 경우를 단방향이라고 하고
 서로가 서로를 참조하는 관계를 양방향이라고 한다.

 

