# Kiosk개발 일지

이번에 키오스크 앱을 리팩토링하면서 든 궁금증들과 내가 어떻게 생각했는지를 기록해보려고 한다. 나중에 보면 옛날의 내 생각들을 알 수 있고 성장했다는 걸 느낄 수 있을 것 같다.

## 준비

 키오스크 앱은 스파르타 코딩클럽 내일배움캠프 스프링 3기 활동을 하며 만든 두 번째 프로젝트다. 
자바를 이용해 CLI키오스크 프로그램을 만드는 게 과제이다. 
<br>
<br>
 우선 요구사항을 보며 필요한 클래스들을 생각했다. 요구사항에 나온 메뉴클래스(이름,설명), 메뉴를 상속받는 상품(이름, 설명, 가격) 그리고 메인 메소드를 실행시키면 출력되는 메인 화면에서는 사용자의 입력애 따라 다른 액션이 수행된다. 그래서 메인 메소드에 while(true)로 무한 루프를 만들었고 그 안에 스위치문을 써서 분기를 해줬다.<br>
 <br>
  자바의 클래스를 역할에 따라 분류할 수 있지 않을까 생각했다. 메뉴와 상품같이 데이터를 형식에 맞게 담아 저장하는 클래스와 뭔가 액션을 취하는 클래스.
 액션을 취하는 클래스에도 더 나눠서 실제 조직에서도 가장 높은 사람과 그 가치관을 이해하고 있는 사람, 그리고 외부 업체로 나눌 수 있지 않을까 해서 그 적극성과 책임에 따라 패키지를 분리하려 했다. 이런 생각에 핸들러 라는 패키지를 만들었다.<br><br>
 데이터를 담는 클래스들은 메뉴, 상품, 장바구니, 주문이고 이번에 만드는 키오스크의 액션은 화면 보여주기(메인, 메뉴보기,장바구니에 추가 주문, 주문완료), 키오스크의 기능(메뉴 카테고리 선택하기, 선택된 카테고리에 맞는 상품 보여주기, 장바구니에 저장, 주문 초기화, 장바구니 확인, 주문하기)이 있다. 여기서 화면을 보여주는 클래스들을 모아서 ui패키지를 만들었고 기능을 수행하는 클래스들을 모아서 handler패키지에 넣어줬다. domain패키지에 메뉴, 상품 등과 같은 일종의 데이터 가방들을 모아놨다.<br><br>
 내가 이해한 객체지향의 컨셉은 이렇다. 전체는 객체들로 구성되는데 각각 내부의 상황이 어떻든지 다른 객체는 영향을 받지 않거나 적게받도록 하는 것이다. 책임이 적은 객체들은 자기 할일만 알고있으면 된다. 변경해야하는 부분 딱 한 부분만 변경하면 되니. 그래야 유지보수적으로 이점을 얻을 수 있을 것이다. <br>
 어디선가 enum에 대한 글을 봤다. enum은 쓰임새가 정말 다양하더라. 상수를 쓸 때도 사용할 수 있고 싱글톤을 구현할 때도 사용할 수 있는등 잘 활용하면 배우는게 많을 것 같아서 이번 프로젝트에서 사용해봤다.

## 시작

 main메소드 안에 while무한 루프를 만들고 switch문을 넣어 1을 넣어보고 2도 넣어서 테스트하며 코딩한다.<br><br>
자바의 라벨을 이용해 특정 버튼을 누르면 무한루프를 탈출하도록 한다.<br> 그 다음으로 핸들러를 작성했다. 가장 간단한 main핸들러부터. main핸들러는 프로그램을 실행했을 때 가장 먼저 보여져야하는 화면이다. 메인 메소드에서 메인 핸들러를 호출하고 메인 핸들러는 메인 ui를 호출한다. 일단 데이터가 없기 때문에 하드코딩식으로 그냥 넣어넣고 테스트했다.<br> 나중에 데이터를 가져와서 출력해줘야한다.<br><br>
메인 화면에서 한 단계 들어가면 선택한 카테고리에 해당하는 데이터들이 나온다. 디테일 메뉴 핸들러를 만들어준다. 그리고 이어서 디테일ui도 만들어준다. 테스트로 디테일 ui에선 System.out.println("상세 메뉴 화면")만 넣었다. 다른 핸들러 클래스들도 똑같이 만들어서 테스트했다. 이제 데이터를 어떻게 다른 클래스에 전달해줄 것인지 고민해봐야겠다. <br><br>데이터 선언은 모범답안의 MenuContext방식을 따라했다. <br>리스트를 만들고 new Product()로 내용들을 넣어줬다.<br><br> 처음엔 상품 이름. 설명, 가격을 실제 쉑쉑버거 메뉴판을 보기도 하고 했지만 중요한 부분이 아니라는 생각이 들어서 대충 넣어줬다.<br><br> 요구사항에서 정해준 건 아니지만 상품의 타입을 정해줘야 할 것 같았다.
버거,아이스크림 등등을 스트링으로 넣어 줄 수도 있지만 마음에 들지 않았다. 만약 입력할 때 오타가 나거나 공백이 들어간다던가 하면 서로 다른 타입이 될 거였기 때문이다. 타입은 딱 정해져있는 값인데... <br><br>마치 객체처럼 쓸 수 있는 타입값을 원했고 enum을 사용했다. 이렇게 해서 좀 깔끔하게 처리할 수 있었다.


## 선택 요구사항

선택 요구사항은 따로 브랜치를 생성해서 작업하려한다. 원본 코드를 수정해야하는데 그냥 그대로 남겨두고 싶기 때문이다. 다른 개발자분의 깃허브를 보니 기능을 새로 개발할 때 브랜치를 만들어서 버전을 두 개로 나누는 게 스마트하다는 생각이 들었다. 그래서 addition브랜치를 만들었다.

### 1. 같은 상품을 장바구니에 추가할 경우 갯수가 증가하게 하기.

 예를 들어 전에는 같은 상품을 추가하더라도 장바구니엔<br> *불고기버거<br> *불고기버거<br> 와 같은 식으로 나왔다. 실제로 저장도 중복되어 저장했다.<br> "같은 상품" 이라는 부분을 보고 Map이 떠올랐다.<br><br> Map은 키와 벨류로 구성되어있고 키에 상품을 넣고 벨류에 상품의 갯수를 넣으면 되겠다 생각했다. 그래서 알게된 Map의 메소드인 getOrDefault. 이 메소드는 찾는 키가 존재한다면 키의 값을 반환하고 없다면 기본값을 반환하는 메소드이다.다음과 같이 쓸 수 있다.
  ```
  map.getOrDefault(Product, DefaultValue);
  ```
   유용한 메소드이다. 만약 무작위로 알파벳이 
   ```
   A,A,C,B,B,C
   ```
   로 주어지는 경우에 해당 메소드로 각 알파벳의 숫자를 카운팅 할 수 있을 것이다.<br><br> 그래서 사용해본 결과 쉽게 선택요구사항 1번을 구현할 수 있었다.<br><br> 내가 집중했던 부분은 한 부분을 수정하더라도 다른 부분을 수정할 필요가 없도록 설계하는 건데 자료형이 달라지니 연관된 클래스에 오류가 생겼다. 리스트의 반복문과 map의 반복문을 쓰는 방식이 조금 달랐기 때문이다. 아쉽다. 다른 방법이 있을까 생각해봐야겠다.<br>


 ### 2. 상품에 옵션넣기.

  햄버거집 키오스크에는 옵션을 선택하면 단품으로 먹을건지 셋트로 먹을건지 선택할 수 있다.<br>
  나는 주로 세트를 먹는다. 탄산없인 못먹겠더라.<br>
  옵션에 대한 정보는 상품이 가지고있는 게 맞다고 생각이 든다.<br> 
  왜냐하면 어떤 상품은 옵션이 없을것이고 또 상품마다 옵션의 가격이 달라지기 때문이다. <br>
  그래서 product 클래스에 필드값으로 설정해주려고 한다.<br><br>
   버거는 단품과 셋트지만 음료의 경우 기본과 라지가 있다. 어떻게 하는 것이 좋을까.<br>
    옵션은 이름과 가격이 있다. 만약 옵션이 없는 경우는 어떻게 해줘야할까?<br>
    옵션이 2개 이상이면 어떻게해야할까 고민하다가 옵션이라는 정보 저장 객체를 만들었다.<br>
    이렇게 옵션을 설정해주고 옵션이 여러가지인 경우에는 <br>
    ```
    List<Option> options
    ```
로 묶어 줄 수 있고 Product의 생성자에 넣어줄 수 있을 것이다.

 ### 3. 총 판매 액수
  3, 4번이 주문완료된 상품들에 대한 내용이기 때문에 Order클래스를 만들어줬다. order안에 프로그램이 실행되는 시점에 생성되는 변수를 만들어주고 주문이 완료되는 시점에 장바구니에 있는 자료들과 그 함계를 Order객체에 전달해주고 갱신하면 될 것이다.

 ### 4. 지금까지 판매된 상품 목록
  3번과 마찬가지로 주문 완료되는 시점에 장바구니의 자료들을 Order객체에 전달해주고 주문 목록을 업데이트 시켜주면 될 것이다.<br>
  근데 중복을 허용하기 때문에 장바구니 map데이터를 List형으로 바꿔주었다. 


## 생각해볼 것들.
* switch-case의 경우 각각의 입력들을 딱 떨어지게 나눈다.
만약 키오스크 상품이 추가되거나 사라지면 번호가 하나씩 밀리거나 당겨지는 일이 생긴다. 어떻게 하면 유연하게 짤 수 있을까


## 새롭게 알게된 것들.
* ```map.getOrDefault()```메소드
* 객체의 내용을 뽑아볼 때 toString을 오버라이드해서 사용했는데 생각해보면 오버라이드 한다는 게 부모 요소에 이미 구현이 되어있는 메소드를 가져와서 자식 요소에서 상황에 맞게 커스텀해서 사용한다는 건데 그 내용을 커스터마이징 할 게 아니라면 하지 않아도 되는거였다.

