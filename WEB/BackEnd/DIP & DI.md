# DIP & DI

## 개요

이번 글의 테마는 이렇다.

> 누구나 시간을 들이면 결국 이러한 결론에 다다를 것이다. - It's me!

설거지를 예로 들어보면 설거지를 할 때 많이 해보지 않은 사람이라면 그릇 하나 거품 묻히고 씻고 또 다른 그릇을 가져와 거품을 묻히고 씻을 것이다.

그러나 하다보면 결국 한 번에 다 거품을 묻혀놨다가 한 번에 모두 씻을 것이다. 누구나 이런 결론을 낸다.

## DIP

DIP는 Dependency Inversion Principle의 약자로 의존 역전 원칙이다.

첫째, 상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.
둘째, 추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.

무슨 뜻인지 살펴보자.

다음과 같은 코드가 있다고 생각해보자.
```java
public class Chef {
  private Pizza pizza;

  public void cook() {
      pizza = new pizza();
      pizza.cook();
  }
}
```

피자만 단일 메뉴로 파는 레스토랑이다. 그러다 손님들의 요구로 Pasta를 개발해 팔기로 했다고 해보자.

위의 코드는 통째로 바뀔 것이다.

```java
public class Chef {
  private Pasta pasta;

  public void cook() {
      pasta = new Pasta();
      pasta.cook();
  }
}
```

근데 쉐프는 주문이 들어오면 주문에 따라 다른 음식을 만들어야하는 것 아닌가.

이런 경우 문제가 생긴다.

주문이 들어올 때마다 쉐프 클래스의 코드가 변경되어야하는 것이다. 이러면 곤란하다.

지금의 구조는 Chef가 음식 메뉴에 해당하는 클래스에 의존하고 있다.

(A가 B의 도움을 받아서 자신의 할 일을 하는 상황을 A는 B에 의존한다고 한다.)

어떻게 하면 메뉴가 추가될 때마다 코드를 바꾸지 않고 요리를 할 수 있을까?

가만히 보니 피자나 파스타나 현재 식당에서 판매중인 메뉴라는 공통점이 있다. 이들의 공통점을 뽑아내 추상화하는 방법은 어떨까? 

```java
public interface Menu {
  void cook();
}
```
```java
public class Pizza implements Menu {
  @Override
  void cook() {
    System.out.println("피자를 요리합니다.");
  };
}
public class Pasta implements Menu {
  @Override
  void cook() {
    System.out.println("파스타를 요리합니다.");
  };
}
```

그렇다면 이전의 코드는 다음과 같이 바뀔 것이다.

```java
public class Chef {
  private Menu menu;
  
  public void cook() {
      menu = new Pasta();
      menu.cook();
  }
}
```

이렇게 하면 통채로 바꿔야하던 코드가 new 키워드로 생성하는 인스턴스만 바꾸어주면 된다.

그러나 여전히 문제가 생기는데 바로 클래스 내부에서 직접 인스턴스를 생성하고 있다는 점 때문이다.

메뉴가 추가되어도, 다른 주문이 들어와도 요리할 수 있게 하고 싶은 건데 이러면 여전히 Chef코드가 변경될 수 밖에 없다.

위의 코드를 우리가 의도한대로 바꾸려면 다음과 같이 바꿔볼 수 있다.

```java
public class Chef {
  private Menu menu;

  public void cook(Menu menu) {
    this.menu = menu;
    menu.cook();
  }
}
```

외부에서 만들어야하는 메뉴를 주입시켜주는 것이다.

이러면 메뉴가 추가되어도, 다른 주문이 들어와도 쉐프 클래스는 변경할 부분이 없다.

이러한 방식의 문제 해결 패턴을 디자인 패턴이라고 하고 그중에서도 DI 패턴을 적용한 것이다.<br>
이렇게 의존관계에 있는 인스턴스를 자동으로 주입시켜주는 것이 바로 스프링 프레임워크다.

문제 해결 과정을 정리해보면 다음과 같다.

1. 상위 모듈인 Chef가 하위 모듈인 구체적인 메뉴에 의존하는 경우 유연성이 떨어지는 문제가 생긴다. 
2. 하위 모듈인 메뉴를 추상화하여 상위 모듈인 Chef가 추상화된 인터페이스에 의존하도록 만든다(DIP).
3. 아직 다른 주문이 들어올 경우 Chef 코드를 변경해줘야하는 문제가 남아있다.
4. Chef클래스 내부에서 인스턴스를 생성하던 것을 외부에서 메뉴 인스턴스를 주입받아 사용하도록 변경한다.(DI)

지금은 쉐프 한 명이 새롭게 주문을 받아야하는 경우를 예로 들었지만 실제론 다음과 같이 사용하는 경우가 더 많을 것이다.

```java
public class Chef {
  private final Menu menu;

  public Chef(Menu menu) {
    this.menu = menu;
  }

  public void cook()) {
    menu.cook();
  }
}
```
DI도 여러 종류가 있는데 위와 같은 방식을 생성자 주입 방식이라고 부른다.

결국 DIP와 DI는 셋트라고 생각이 든다.

상위 모듈이 구체적인 하위 모듈에 의존하도록 하위 모듈을 추상화 해야했고(DIP) 이러한 상황에서 구현체가 변하더라도 상위 모듈의 코드가 변경될 일이 없게 하기 위해서 DI패턴을 적용했다.
ㄴ> 결합도 감소, 유연성 향상

그리고 테스트도 용이하다고 하는데 이건 무슨 이유일까?

이건 테스트시 외부에서 가짜 객체를 주입하여 테스트할 수 있기 때문이다.

슬라이스 테스트시 해당 계층이 의도한 대로 잘 작동하는지를 테스트해야할 것인데

만약 내부적으로 인스턴스를 생성하는 경우 의존 관계에 있는 인스턴스를 컨트롤 할 수 없게된다.

DI패턴을 이용하면 해당 계층 내부에서 사용하는 인스턴스를 주입시켜주기 때문에 외부 의존 인스턴스를 모킹(정해진 동작을 하도록 설계)하여 주입시켜줌으로써 내가 테스트하기를 원하는 계층만 테스트할 수 있다.
