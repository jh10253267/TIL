# Test

# 개요
  프로그램을 사용하다 버그를 발견해본 적이 있을 것이다. 내가 원하는 작업을 하는데 큰 영향이 없는 버그들부터 내가 할 일에 지장을 끼치는 버그들까지.<br>
  좀더 좋은 프로그램을 작성하려면 테스트에 대해 공부해볼 필요가 있다.

## Testing?
  테스팅이란 응용 프로그램 또는 시스템의 동작과 성능, 안정성이 요구하는 수준을 만족하는지 확인하기 위해서 결함을 발견하는 과정이라고 할 수 있다.

  테스팅을 떠올렸을 때 우리는 프로그램이 잘 작동하는지 아닌지를 확인하는 의미의 테스팅을 쉽게 떠올릴 수 있다. 

 그러나 테스팅은 단순한 기능이 잘 작동하는지 여부 외에도 요구사항과 사용자의 기대 수준에 맞게 구현되고 동작하는지를 확인하고 최종적인 결함 데이터를 근간으로 개발 프로젝트의 리스크에 대한 수치적인 판단 근거를 의사 결정권자에게 전달하는 것을 의미한다.

 그래서 테스트는 굉장히 중요하게 되는데 테스팅을 이용한 개발 방법론도 존재한다. TDD방식과 BDD방식이 그러하다.

 이중 BDD의 관점에서 보면 테스트 자체가 하나의 요구사항 명세가 될 수 있어서 테스트를 작성하고 수행하는 방법을 익혀두면 좋다. 또한 어떤게 좋은 테스트인지 내가 작성한 테스트가 하나의 명세가 되려면 어떻게 하는 것이 좋을지 생각해보면 좋을것이다.

## 정적 테스트 & 동적 테스트
  용어의 뉘앙스에서 알 수 있듯이 프로그램을 개발하기 전에  테스트하는 방법을 정적테스트라고 하고 프로그램 개발 이후에 실제 실행하면서 테스트하는 것을 동적 테스트라고 한다.

## 테스트가 필요한 이유
  우리가 수행하는 프로젝트는 아직 작은 스케일의 프로젝트이다. 그렇기에 테스트를 수행하지 않아도 큰 리스크가 없는데 어떤 부분에선 큰 사고로까지 이어질 수 있다. 기계안에도 소프트웨어가 있기 때문에 기계가 잘못 작동되어 인명사고가 날 수도 있고 금전적인 피해가 발생할 수 있다.

## 테스팅의 일반적인 원칙
1. 테스팅은 결함이 존재함을 밝히는 작업이다.
  테스팅은 결함이 존재함을 밝힐 수 있지만 결함이 없다는 것을 증명할 수 없다. 그렇기에 테스트가 잘 동작한다고 해서 테스트를 하지 않은 부분 또한 결함이 있는지 없는지에 대해 예측할 수 없다.
2. 완벽한 테스팅은 불가능하다.
  모든 가능성을 테스팅하는 것이 가장 확실하겠지만 한 프로그램 내부 조건은 무수히 많고 입력이 가질 수 있는 모든 값의 조건이 무수히 많다. 그렇기에 완벽한 테스팅은 불가능하다. 그렇기에 완벽한 테스팅 대신 리스크 분석과 우선순위에 따라 테스팅에 필요한 노력을 집중시켜야한다.

3. 테스팅은 개발 초기에 시작되어야한다.
  테스팅은 개발 주기에서 초기에 시작되어야하고 설정한 테스팅 목표에 집중해야한다. 이는 개발의 시작과 동시에 테스트를 계획하고 전략적으로 접근하고 개발 중간 산출물을 분석하여 테스트하는 것을 의미한다.

## Junit
 프로그래밍 언어마다 테스트를 위한 프레임워크가 존재하는데 이러한 도구들을 보통 xUnit이라고 한다. 

 Junit은 자바에서 사용되는 테스트 프레임워크의 이름이다.

 우리가 처음 자바 프로그램을 작성할 때 가장 간단하게 테스트할 수 있는 방법은 메인 메소드를 하나 열어서 입력한 값들이 잘 나오는지 확인하는 방법일 것이다. 

 그러나 이렇게 작성한 테스트들은 불완전하기도 하고 프로덕션코드와 섞이게 된다는 문제가 있다. 그리고 내가 테스트한 내용이 실제 서비스되어야하는 로직에 관여하여 영향을 주게 된다.
 
 이러한 방식은 바람직하지 않고 불편하다.
 
 그렇기에 Junit을 이용해 테스트 패키지에서 테스트하는 편이 좋다. 
  
 Junit은 @Test라는 애노테이션으로 하나의 테스트를 설계할 수 있는데 각각의 @Test애노테이션이 붙은 메소드마다 새로운 인스턴스가 생성되어 독립적인 테스트가 가능하다.

## FIRST 원칙

## Junit을 이용한 테스트 방법
메소드를 작성하고 내가 테스트하려는 메소드 위에 @Test애노테이션을 붙인다. 그럼 각 테스트 메소드들이 서로 영향을 주지 않고 독립적인 흐름으로 실행된다.

그리고 테스트를 수행할 때 성공했는지 안했는지 확인하려면 화면에 어떤 값을 출력해야한다. 그러나 매번 이렇게 직접 확인하는 건 불편하다. 그래서 테스트를 수행할 때 assert라는 메소드를 이용해 값을 체크한다.

개인적으론 AssertJ라는 의존성을 추가해서 사용하는 걸 선호하는데 이 라이브러리는 테스트 코드의 가독성을 높여준다.
예를 들어 기본적인 Junit의 assert는 다음과 같이 사용한다.


```java
assertEquls(exepected, actual);
```

우리가 자신이 만든 함수를 사용할 때 어떤 파라미터를 어떤 순서로 넣어줘야하는지 헷갈릴 때가 있듯이 위의 코드도 마찬가지다. 파라미터 순서가 헷갈릴 수 있다. 가독성도 좋지 않다.

```java
assertThat(actual).isEqualTo(expected);
```

위의 코드는 AssertJ를 이용한 방식이고 왼쪽에서 오른쪽으로 자연스러운 흐름이 보인다. 그리고 검증(실제값).검증 메소드의 방식으로 사용할 수 있어서 복잡한 사용법이 필요하지 않다.

## Mock
 대부분의 시스템은 DB라던가 외부 API등의 외부 시스템이 의존하고있다. 이러한 가변적인 영역은 관리하기가 어렵고 테스트를 할 때 단위 테스트의 범위를 벗어나게된다. 
 
 예를 들어 비즈니스 로직을 검증할 때 DB의 동작까지 함께 테스트를 해야할까

 비즈니스 로직을 검증하려면 비즈니스 로직만 검사하는게 바람직하다. 
 
 이처럼 하나의 빈이 가지고 있는 기능만 잘 동작하는지 확인하는 것을 단위테스트라고 한다.

 이 때 사용할 수 있는 것이 mockito 프레임워크이다.  mockito를 사용하면 테스트환경에서 필요한 의존성을 대체할 수 있다.
 
 mockito는 영화 내부자들에 나온 명대사 "모히또애서 몰디브 한 잔 할까?"의 모히또에서 이름을 따왔다고 하고 mockito는 오픈소스 목 프레임워크로 테스트를 위해 가짜 객체를 쉽게 만들어 줄 수 있는 프레임워크이다.

 ![](https://cphinf.pstatic.net/mooc/20200214_263/1581664722932hBxQi_PNG/2.png?type=w760)
 
위와 같은 클래스가 있고 나는 MyService를 테스트하려 한다고 해보자 그러나 MyService는 CalculatoerService에 의존하고있다. 이러한 관계로 인해 MyService가 잘 작동함에도 CalculatorService의 버그로 오류가 생길 수 있다. 따라서 Mock 가짜 객체를 하나 생성함으로써 내가 원하는 부분만 테스트를 수행할 수 있다.

그래서 Mock을 만들고 Mock의 행동을 정하고 정상적으로 동작하는지를 제공한다.
 
 ## SpringBootTest
 스프링을 이용한다는 것은 개발자가 직접 인스턴스를 생성하지 않는다는 의미다. 스프링을 사용한다는 것은 스프링 빈 컨테이너가 인스턴스를 생성해 관리하는 방식을 이용한다는 것을 의미한다. 이는 스프링 테스트에도 마찬가지인데 스프링 테스트는 관련된 빈 설정을 읽고 인스턴스를 주입해준다.

스프링 부트는 기본적인 테스트 스타터를 제공한다. 따라서 별도의 의존성 추가 없이도 쉽게 테스트할 수 있다.

스프링 부트 테스트를 위해 알고있어야하는 어노테이션은 다음과 같은 것들이 있다.
* @SpringBootTest
* @WebMvcTest
* @DataJpaTest

위에서 아래의 차례대로

* 통합테스트를 위한 어노테이션
* 컨트롤러단 테스트를 위한 어노테이션
* 레포지토리단 테스트를 위한 어노테이션

웬만해선 첫번째의 @SpringBootTest를 사용하면 큰 문제 없이 테스트가 가능하다. 이 어노테이션은 실제 구동되는 애플리케이션과 같이 ApplicationContext를 로드하여 테스트하기 때문에 하고싶은 테스트를 모두 수행할 수 있다.

그러나 빈과 관련된 모든 설정을 읽어오기 때문에 경우에 따라서는 무겁고 느리고 불필요할 수 있다. 그래서 통합테스트시 사용하는 것이 바람직하다 할 수 있겠다.

그래서 각 계층을 테스트를 하는 방식으로 테스트를 수행할 수 있는데 이를 슬라이스 테스트라고 하며 스프링부트 테스트에는 슬라이스 테스트를 위한 어노테이션도 당연히 존재한다.

### @WebMvcTest
@WebMvcTest를 사용했을 때 스프링이 읽어오는 설정들은 대표적으로 @Controller어노테이션이 붙은 클래스들, 

기본적으로 모든 컨트롤러들을 다 읽어들이지만 
```java
@WebMvcTest(ArticleController.class)
```
위와 같이 클래스를 명시해서 테스트 대상만 읽어들이는 것이 가능하다.

### @DataJpaTest
Jap와 관련된 요소들만 테스트하기 위한 어노테이션으로 JPA테스트에 관련된 설정들만 읽어온다. 그리고 각 테스트가 완료되면 관련된 설정들은 롤백된다.

 테스트를 위한 execution이 데이터베이스에 영향을 미치지 않게 하기 위함이다. 이는 @SpringBootTest에서도 비슷하게 작동하게 할 수 있다.
 바로 @Transactional어노테이션을 붙이는 방식이다. 이렇게 하면 해당 테스트의 수행 결과가 롤백된다.

 그리고 테스트용 DB를 사용하여 원하는 테스트 데이터베이스(H2 등)로 테스트할 수 있다.
  
--------------

## 실습

### Given_When_Then 패턴
테스트에도 여러가지 컨벤션 같은 것들이 있는데 대표적인 것이 Given_When_Then패턴이다.
 이름 그대로의 사용법으로

Given은 테스트를 위해 준비하는 과정이다.

When은 실행하는 부분

Then은 테스트를 검증하는 부분이다.

에를 들어 계산기 프로그램을 작성했다고 해보자. 그 중 덧셈 로직을 테스트하고 싶은 상황이다.

그렇다면 이렇게 테스트를 작성할 수 있다.(AssertJ를 사용하겠다.)
일단 테스트에 대해 설명하는 @DisplayName어노테이션을 붙여주고 시작한다.

```java
@DisplayName("계산기 덧셈 테스트")
@Test
void givenTwoNumbers_whenDoAddition_thenReturnsResult {
  // Given
  int num1 = 1;
  int num2 = 2;
  int expectedResult = num1 + num2;
  String operator = "+";

  // When
  int sum = Calculator.calculate(num1, operator, nume2);
    
  // Then
  assertThat(sum).isEquals(expectedResult);
}
```
### WebMvcTest
WebMvcTest는 다음과 같이 사용할 수 있다.
테스트를 위해 MocMvc객체를 받아오고 ```.perform```메소드를 이용한다. 예시의 테스트는 /articles에 Get요청을 보내고있고 andExpect로 요청에 대한 응답을 검증하고있다. 여기서 주의깊게 볼 부분은 응답의 컨텐츠타입을 검증하는 부분이다. ```.contentType```을 사용할 경우 엄격하게 일치여부를 따지지만 실제 응답에선 charset=UTF-8이 같이 포함되어 있을 수 있다. 그래서 ```contentTypeCompatibleWith```를 사용할 경우 rough하게 체크하기 때문에 우리가 의도한대로 테스트를 할 수 있다.


```java
@WebMvcTest(ArticleController.class)
@DisplayName("View 컨트롤러 - 게시글 호출 테스트")
class ArticleControllerTest {
    private final MockMvc mvc;

    ArticleControllerTest(@Autowired MockMvc mvc) {
        this.mvc = mvc;
    }

    @DisplayName("게시글 리스트 페이지 - 정상호출")
    @Test
    void givenNothing_whenRequestArticlesView_thenReturnsArticlesView() throws Exception {
        // Given

        // When & Then
        mvc.perform(get("/articles"))
                .andExpect(status().isOk())
                .andExpect(content().contentTypeCompatibleWith(MediaType.TEXT_HTML))
                .andExpect(view().name("articles/index"))
                .andExpect(model().attributeExists("articles"));

        
    }
```
### DataJpaTest

DataJpaTest는 영속계층을 테스트하기 위한 어노테이션이다. 테스트는 항상 일정해야하며 독립적으로 타겟의 작동만 테스트할 수 있어야한다. 예를 들어 일반 통합테스트를 수행하면 DB에 내용이 들어가고 내용이 삭제된다. 만약 delete테스트를 수행해서 해당 id값을 가진 엔티티가 없는데 select테스트를 수행하면 테스트에 실패한다. 실제 테스트하려는 기능은 제대로 작동한다고 해도 말이다. 이런 문제를 @SpringBootTest에서 @Transactional어노테션을 붙여주어 해결할 수도 있지만 슬라이스테스트라고 보긴 어렵다. 그래서 @Transactioanl 어노테이션이 내장되어있는 DataJpaTest로 해결할 수 있다.

DataJpaTest는 JPA와 관련된 설정들만 읽어오고 기본적으로 롤백이 수행된다. 즉 테스트 상황에서의 변경점이 데이터베이스에 반영되지 않는다. 






