# Test

# 개요
  프로그램을 사용하다 버그를 발견해본 적이 있을 것이다. 내가 원하는 작업을 하는데 큰 영향이 없는 버그들부터 내가 할 일에 지장을 끼치는 버그들까지.<br>
  좀더 좋은 프로그램을 작성하려면 테스트에 대해 공부해볼 필요가 있다.

## Testing?
  테스팅이란 응용 프로그램 또는 시스템의 동작과 성능, 안정성이 요구하는 수준을 만족하는지 확인하기 위해서 결함을 발견하는 과정이라고 할 수 있다.
  테스팅을 떠올렸을 때 우리는 프로그램이 잘 작동하는지 아닌지를 확인하는 의미의 테스팅을 쉽게 떠올릴 수 있다. 

 그러나 테스팅은 단순한 기능이 잘 작동하는지 여부 외에도 요구사항과 사용자의 기대 수준에 맞게 구현되고 동작하는지를 확인하고 최종적인 결함 데이터를 근간으로 개발 프로젝트의 리스크에 대한 수치적인 판단 근거를 의사 결정권자에게 전달하는 것을 의미한다.

  그래서 테스트는 굉장히 중요하게 되는데 테스팅을 이용한 개발 방법론도 존재한다. TDD방식과 BDD방식이 그러하다.
  이중 BDD의 관점에서 보면 테스트 자체가 하나의 요구사항 명세가 될 수 있어서 테스트를 작성하고 수행하는 방법을 익혀두면 좋다.

## 정적 테스트 & 동적 테스트
  용어의 뉘앙스에서 알 수 있듯이 프로그램을 개발하기 전에  테스트하는 방법을 정적테스트라고 하고 프로그램 개발 이후에 실제 실행하면서 테스트하는 것을 동적 테스트라고 한다.

## 테스트가 필요한 이유
  우리가 수행하는 프로젝트는 아직 작은 스케일의 프로젝트이다. 그렇기에 테스트를 수행하지 않아도 큰 리스크가 없는데 어떤 부분에선 큰 사고로까지 이어질 수 있다. 기계안에도 소프트웨어가 있기 때문에 기계가 잘못 작동되어 인명사고가 날 수도 있고 금전적인 피해가 발생할 수 있다.

## 테스팅의 일반적인 원칙
1. 테스팅은 결함이 존재함을 밝히는 작업이다.
  테스팅은 결함이 존재함을 밝힐 수 있지만 결함이 없다는 것을 증명할 수 없다. 그렇기에 테스트가 잘 동작한다고 해서 테스트를 하지 않은 부분 또한 결함이 있는지 없는지에 대해 예측할 수 없다.
2. 완벽한 테스팅은 불가능하다.
  모든 가능성을 테스팅하는 것이 가장 확실하겠지만 한 프로그램 내부 조건은 무수히 많고 입력이 가질 수 있는 모든 값의 조건이 무수히 많다. 그렇기에 완벽한 테스팅은 불가능하다. 그렇기에 완벽한 테스팅 대신 리스크 분석과 우선순위에 따라 테스팅에 필요한 노력을 집중시켜야한다.

3. 테스팅은 개발 초기에 시작되어야한다.
  테스팅은 개발 주기에서 초기에 시작되어야하고 설정한 테스팅 목표에 집중해야한다. 이는 개발의 시작과 동시에 테스트를 계획하고 전략적으로 접근하고 개발 중간 산출물을 분석하여 테스트하는 것을 의미한다.

## Junit
자바 프로그램을 테스트할 때 Junit이라는 테스트 프레임워크이다.
우리가 처음 자바 프로그램을 작성할 때 가장 간단하게 테스트할 수 있는 방법은 메인 메소드를 하나 열어서 입력한 값들이 잘 나오는지 확인하는 방법일 것이다. 그러나 이렇게 작성한 테스트들은 불완전하고 프로덕션코드와 섞이게 된다. 이런 방법은 바람직하지 않고 불편하다. 그렇기에 Junit을 이용해 테스트 패키지에서 테스트하는 편이 좋다. Junit은 @Test라는 애노테이션으로 하나의 테스트를 설계할 수 있는데 각각의 @Test애노테이션이 붙은 메소드마다 새로운 인스턴스가 생성되어 독립적인 테스트가 가능하다.

## FIRST 원칙

## Junit을 이용한 테스트 방법
메소드를 작성하고 내가 테스트하려는 메소드 위에 @Test애노테이션을 붙인다. 그럼 각 테스트 메소드들이 서로 영향을 주지 않고 독립적인 흐롬으로 실행된다.
그리고 테스트를 수행할 때 성공했는지 안했는지 확인하려면 화면에 어떤 값을 출력해야한다. 그러나 매번 이렇게 직접 확인한다면 불편하다. 그래서 테스트를 수행할 때 assert라는 메소드를 이용해 값을 체크한다.

개인적으론 AssertJ라는 의존성을 추가해서 사용하는 걸 선호하는데 이 라이브러리는 테스트 코드의 가독성을 높여준다.
예를 들어 기본적인 Junit의 assert는 다음과 같이 사용한다.
```java
assertEquls(exepected, actual);
```
우리가 자신이 만든 함수를 사용할 때 어떤 파라미터를 어떤 순서로 넣어줘야하는지 헷갈릴 때가 있듯이 위의 코드도 마찬가지다. 파라미터 순서가 헷갈릴 수 있다. 가독성도 좋지 않다.

```java
assertThat(actual).isEqualTo(expected);
```
위의 코드는 AssertJ를 이용한 방식이고 왼쪽에서 오른쪽으로 자연스러운 흐름이 보인다. 그리고 검증(실제값).검증 메소드의 방식으로 사용할 수 있어서 복잡한 사용법이 필요없다.






