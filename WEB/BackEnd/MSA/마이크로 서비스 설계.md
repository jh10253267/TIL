# 마이크로서비스 설계

## 개요

도메인 주도 개발로 시작하는 마이크로서비스 개발 책을 공부하며 내용을 이해해보려한다.

## 핵심

소프트웨어를 개발할 때 모듈화는 굉장히 중요하다. 각 모듈의 응집도는 높게 만들고 기능이 다른 다른 모듈과의 결합도는 낮추는 것이 원칙이다.

마이크로 서비스에서도 기능적으로 응집성있는 마이크로서비스를 도출하고 타 서비스 간의 의존도는 낮추어야한다.

이를 위해 가이드로 삼을 수 있는 것이 DDD이다.

마이크로 서비스의 장점은 독립적으로 변경 및 배포가 가능하다는 것이다. 이를 위해선 각 마이크로서비스가 다른 서비스와 의존하지 않게 도출해야한다.

이를 위해 어떤 비즈니스 기능들을 묶어서 독립적인 마이크로서비스를 도출할 것인지를 결정하는 것이 중요하다.

## 마이크로서비스 내부 구조 정의

마이크로서비스와 같이 기존 모노리스의 기능들을 쪼개서 구조적 복잡성을 해결할 수 있지만 여전히 내부 복잡성이 존재한다.

마이크로 서비스의 내부 구조는 각 서비스의 목적과 활용도에 따라 달라질 수 있다고한다. 이를 폴리글랏하다고 표현한다.

예를 들어 자바, 오라클 DB, DDD와 같이 구성할 수도 있고 ASP.NET Core,  SQL Server, DDD와 같이 구성할 수도 있다.

레이어드 아키텍처, 헥사고날 아키텍처, 클린 아키텍처의 목적과 지향점을 정의하고 마이크로서비스의 내부 구조를 정의해볼 수 있다.

* 지향하는 관심사에 따라 응집성을 높이고 관심사가 다른 영역과는 결합도를 낮춘다.
* 업무 규칙을 정의하는 비즈니스 로직 영역을 다른 기술 기반 영역으로부터 분리하는 것이 좋다.
* 세부 기술 중심, 저수준의 외부 영역, 고수준의 내부 영역으로 구분한다.
* 고수준 영역은 저수준 영역에 의존하지 않도록하고 저수준 영역이 고수준 영역에 의존하게한다.
* 저수준 영역은 언제든지 교체 및 확장이 가능해야한다. 이와 동시에 고수준 영역에 영향을 주면 안된다.
* 인터페이스는 고수준의 안정된 영역에 존재해야하고 저수준의 어댑터가 이를 구현한다.

<img width="436" alt="스크린샷 2024-06-04 시간: 18 19 47" src="https://github.com/jh10253267/TIL/assets/108499717/69fef7d3-0fd4-4fd2-a9a6-444540ac6d81">

내부 영역의 제일 중심에는 도메인이 존재하고 도메인을 서비스가 감싼다. 도메인에는 핵심 비즈니스 개념과 규칙을 정의하고 서비스에서는 도메인을 호출하여 업무를 처리하는 절차를 정의한다.

외부 영역과 연계하기 위해 서비스단은 인터페이스 기반으로 설계한다.

내부 영역에는 저장소 처리를 위한 레포지토리 인터페이스가 존재한다. 기본적인 저장소 처리 사항을 추상화하여 외부 영역의 어댑터는 이 인터페이스를 저장소에 맞는 세부 기술로 구현한다.

외부 영역에는 저장소 처리 어댑터뿐만 아니라 인바운드, 아웃바운드 어댑터가 존재한다. 모든 아웃바운드 어댑터는 DIP를 적용하여 외부 영역에서 내부 영역에 의존하도록 설계한다.


## DDD

DDD에서는 하나의 큰 도메인에서 중요한 것들을 찾고 중요도에 따라 도메인을 나누고 각 도메인을 해결하는 방법이 기본이다.


## 이커머스 서비스 설계

### 비즈니스 능력에 근거한 도출

가장 쉬운 방법은 경험적인 원칙을 적용하는 것이다.

각 도메인에서는 비즈니스가 규정하는 일하는 방식과 조직, 부서 체계가 이미 정의되어있고 이러한 부서는 이미 업무 처리에서의 응집성을 가지고 있고 다 부서와의 의존도는 낮을 것이다.

이렇게 비즈니스 부서가 가진 역할, 처리 능력을 체계적으로 분해할 수 있다.

### DDD의 바운디드 컨텍스트 기반 도출

서비스가 소유권을 가진 데이터를 독립적으로 식별하는 것이 중요하다.

서비스가 보유한 기능에 의해서만 접근 가능한 데이터를 파악해야한다.

그러나 기능 분해 방식은 서비스가 소유해야 할 데이터 식별에 적합하지 않고 기능과 데이터가 분리되고 하나의 통합 데이터가 여러 기능에서 사용도도록 모델링되는 방식이다.

DDD는 데이터를 기능과 분리해서 식별하지 않고 문제 영역인 하위 도메인마다 별도의 도메인 모델로 정의한다.

DDD의 전략적 설계에서는 비즈니스 응집성이 있는 컨텍스트를 구분하고 이를 바운디드 컨텍스트라고 한다. 이 단위가 마이크로서비스를 식별하기 위한 단위로 쓰일 수 있다.

### 도메인과 서브도메인

하나의 큰 도메인에서 중요한 것들을 찾아서 중요도에 따라 도메인을 나누고 각 도메인을 하나씩 해결하는 방법을 기본으로 삼는다.

서브도메인은 중요도에 따라 핵심 서브도메인, 지원 서브도메인, 일반 서브도메인의 세 가지 유형으로 나뉜다.

핵심 서브도메인은 가장 큰 투자가 필요한 영역을 말하고 지원 서브도메인은 비즈니스에 필수적이지만 핵심은 아닌 부분으로 볼 수 있다.

일반 서브도메인은 비즈니스 솔루션에 필요한 부분으로 기존 재품을 구매해서 대체할 수 있다.

예를 들어 아마존에서 한 번이라도 검색했던 상품은 계속 추천목록에 떠서 구매자의 소비를 촉진한다.

쿠팡의 경우는 로켓배송을 핵심 서브도메인으로 선정했을 것이다.

### 도메인 이벤트 찾기

시간의 흐름에 따라 시스템의 동작을 의미하는 도메인 이벤트를 도출하는 단계이다.

이 단계에서는 데이터나 데이터의 구조가 아닌 비즈니스 흐름에서 발생한 이벤트에 초점을 두는 것이 중요하다.

이벤트 명은 과거형 동사로 작성한다.

도메인 이벤트는 비즈니스의 어떤 상태를 생성, 변경, 삭제하는 요소이다.

사용자가 회원가입을 한 뒤 서비스를 이용할 수 있으므로 회원가입, 수정, 탈퇴에 해당하는 도메인 이벤트를 도출한다.

* 회원가입됨
* 회원정보수정됨
* 회원정보삭제됨

회원가입 후 상품이 등록되고 주문과 배송이 이루어지는 과정을 이벤트로 파악한다.
<img width="318" alt="스크린샷 2024-06-09 시간: 20 52 21" src="https://github.com/jh10253267/TIL/assets/108499717/658e2439-764f-41dd-911e-ae8688036a85">


* 상품등록됨
* 상품정보수정됨
* 상품재고수정됨
* 상품재고삭제됨
* 카테고리등록됨


* 배송정보생성됨
* 상품발송됨

* 주문아이템검색됨
* 주문아이템주문됨
* 결제승인됨
* 결제거부됨
* 구입완료됨
* 재고변경됨
* 배송요청됨

* 상품주문취소됨
* 결재취소됨
* 재고변경됨

### 외부 시스템 도출

이벤트를 도출하며 레거시 시스템이나 외부 시스템의 연결을 통해 업무의 흐름이 진행될 때는 프로세스의 이름을 이벤트 오른쪽 상단에 붙이고 화살표를 그려 이 외부 시스템을 호출한다는 것을 표시한다.

시스템 이름은 명사로 적는다.

회원가입과 회원 정보가 수정될 때 회원 정보의 유효성을 판단하는 시스템과 연계하고 주문 아이템 주문돔 이벤트와 연결되는 외부의 결제 시스템, 결제 승인됨 이벤트와 연계되는 이메일 시스템을 도출할 수 있다.

* 결재 시스템
* 이메일 시스템

### 커맨드 도출

도메인 이벤트를 식별한 뒤 이 이벤트를 동작하게 하는 커맨드를 찾는다.

커맨드명은 도메인 이벤트를 동작하게 하는 것으로 동사형태로 작성한다.

* 회원가입/회원가입됨
* 회원정보수정/회원정보수정됨
* 회원탈퇴/회원정보삭제됨

이렇게 회원가입됨 이벤트를 트리거하는 커맨드로 회원가입을 도출할 수 있다.

### 핫스팟 도출

핫스팟은 진행 과정에서 의문 사항이 생기거나 참여하는 사람들이 결정하기 힘든 사항, 다른 부서나 외부에 문의해야하는 것들을 파악한다.

예를 들면 상품 주문 취소의 경우 취소 가능 시점 확인이라는 핫스팟을 붙일 수 있다.

### 액터 도출

커맨드를 실행하는 액터를 도출하는 단계로 액터란 사용자, 조직, 역할자등을 의미한다.

예를 들어 회원가입/회원가입됨의 경우 액터는 게스트로 정의할 수 있다.

엑터를 도출하면서 문장을 만들어 식별한 커맨드와 이벤트를 검토할 수 있다.

판매자가 상품을 등록하면 상품등록됨 이벤트가 발생함으로써 시스템이 동작한다.

구매자가 상품 주문을 취소하면 상품주문취소됨 이벤트가 발생하고 이어서 주문 취소된 상품의 재고를 변경하는 재고변경됨 이벤트가 발생함으로써 시스템이 동작한다.

### 애그리거트 정의

애그리거트는 커맨드와 도메인 이벤트가 영향을 주는 데이터 요소로 도메인의 실체 개념을 표현하는 객체인 엔티티가 된다.

### 바운디드 컨텍스트 그리기

이렇게 도출한 애그리거트를 보면 일부는 이름이 같거나 유사하다. 이를 완전히 다른 애그리거트와 구분해서 경계를 그린다.

이 경계를 바운디드 컨텍스트라고 한다.

각 바운디드 컨텍스트에는 이름을 부여한다.

컨텍스트의 이름은 해당 컨텍스트 내의 애그리거트 이름으로 정의한다.

만약 여러개의 애그리거트가 있는 경우 전체를 아우를 수 있는 대표 이름을 정한다.

다음은 정책 도출로 이벤트 뒤에 따라오는 반응적인 비즈니스 로직을 말한다.

이는 어딘가에 존재하는 커맨드를 동작하게 한다.

따라서 정책은 "도메인이벤트할때는 항상 커맨드한다" 가 된다.

이렇게 바운디드 컨텍스트가 식별되고 각 컨텍스트간의 경계가 파악된다.

이제 바운디드 컨텍스트 간의 관계를 별도의 맵으로 표현할 수 있다. 이 때 호출 관계의 방향과 호출 방식을 판단하여 작성한다.

<img width="474" alt="스크린샷 2024-06-09 시간: 20 53 55" src="https://github.com/jh10253267/TIL/assets/108499717/9ee68eb2-930a-41ab-a4d5-6a004b31179d">

<img width="352" alt="스크린샷 2024-06-09 시간: 20 55 13" src="https://github.com/jh10253267/TIL/assets/108499717/700b2f87-45c7-4a9e-bde8-8e68c96d26d2">


컨텍스트 간에 항상 일관된 데이터가 필요할 경우 동기 호출로 표현하고 결과적 일관성으로 충분히 처리 가능한 관계는 비동기 방식으로 표현한다.

일반적으로 동기방식은 실시간 동시 처리를 위해 호출하고 응답을 대기하는 방식으로 두 컨텍스트 간의 의존도가 높아지고 비동기 방식은 컨텍스트 내에서 처리한 후 이벤트를 발행해 연관된 다른 컨텍스트가 이벤트를 받아 처리할 수 있게 하는 방식으로 두 컨텍스트 간의 의존성을 낮출 수 있다. 따라서 실시간 정합성이 필요한 경우가 아니라면 비동기 방식의 연계를 고려하는 것이 좋다.

고객이 상품을 주문할 때 상품 구매를 위해 클라이언트를 통해 구매 컨텍스트에 동기방식으로 접근한다.

구매 컨텍스트는 구매하려는 상품의 현재 가격을 불러오기 위해 상품 컨텍스트에 동기방식으로 연동하고 회원 컨텍스트에도 현재의 결제 정보와 배송지 정보를 가져오기 위해 동기 방식으로 연동한다.

구매 컨텍스트와 배송 컨텍스트는 비동기로 정의해서 배송 컨텍스트에 장애가 발생한 경우에도 주문을 계속 처리할 수 있는 고가용성을 보장한다.

### 백엔드 모델링

이벤트 스토밍 결과를 반영하여 마이크로서비스의 내부를 헥사고날 구조로 정의하고 매핑할 수 있다.

이벤트 스토밍의 커맨드는 헥사고날의 인바운드 어댑터의 하나인 REST API가 되고 애그리거트는 헥사고날의 내부 영역인 도메인 모델이 되며 도메인 이벤트는 헥사고날 외부 영역의 아웃바운드 메시지 처리 어댑터의 처리 대상이 되고 외부 시스템은 아웃바운드 어댑터가 호출해야할 외부 연계 시스템으로 매핑된다.

주문항목검색, 주문아이템주문, 상품주문취소 커맨드는 클라이언트나 다른 마이크로 서비스에서 접근할 수 있는 REST API로 매핑되고 회원 서비스와 상품 서비스는 REST API로 연계하고 정책으로 식별한 재고 변경은 비동기 연계를 위해 메시지 브로커로 매핑된다. 애그리거트로 식별했던 상품과 결제는 도메인 모델에 매핑되어 데이터베이스에서 관리된다.

<img width="446" alt="스크린샷 2024-06-09 시간: 20 50 11" src="https://github.com/jh10253267/TIL/assets/108499717/64ecefc6-2c28-4344-875b-82999e2cc658">
