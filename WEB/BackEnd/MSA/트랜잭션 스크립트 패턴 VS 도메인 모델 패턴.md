# 트랜잭션 스크립트 패턴 VS 도메인 모델 패턴

## 개요

비즈니스 로직은 어디에 위치하는 것이 좋을까?

일반적으로 3계층 내부 구조를 사용하여 모노리스로 서비스를 개발한다면 도메인 객체에는 getter/setter 혹은 update, 팩토리 매소드 패턴등의 코드만 작성하고 서비스 계층에서 이 도메인 객체를 받아서 비즈니스 로직을 전개한다.

이 경우 서비스 계층은 적극적이라고 할 수 있고 도메인 객체는 수동적인 역할이라고 할 수 있다.  
이러한 패턴을 트랜잭션 스크립트 패턴이라고 한다.

다른 방법도 있는데 바로 도메인 객체에 로직을 구현하는 방법이다. 이 경우 비즈니스 로직이 얇아진다고 표현한다.

어떤 차이가 있고 어떤 장단점이 있을까?

## 트랜잭션 스크립트 패턴

트랜잭션 스크립트 패턴은 우리가 쉽게 이해할 수 있는 로직으로 구성된다. 예를 들어 ATM기에서 출금을 한다고 해보면 다음과 같은 작업들로 이루어져있을 것이다.
1. 카드를 넣고 비밀번호로 인증한다.
2. 출금하려는 금액을 입력한다
3. 잔고와 출금 희망 금액을 비교해서 출금을 처리한다.

이를 서비스단에서 코드로 구현하는 패턴이 바로 트랜잭션 스크립트 패턴이다.

장점으로는 구현이 간단하고 코드를 이해하기 쉽다는 점이 있다.

그러나 모든 비즈니스 로직을 서비스 계층에서 구현하기 때문에 프로젝트의 규모가 커지게되면 서비스 계층의 복잡도가 커지게되고 도메인 객체는 정보 묶음의 역할만 하게된다.

또한 비슷한 유스케이스의 경우 서비스에 중복되는 코드가 생겨날 수 있다. 이러한 특징이 유지보수를 어렵게 할 수 있다.

이런 문제의 해결책이 될 수 있는 패턴이 바로 도메인 모델 패턴이다.

## 도메인 모델 패턴

도메인은 모델 패턴은 동작과 데이터를 모두 통합하는 도메인의 개체 모델이다.

즉 비즈니스 로직이 도메인 객체 안에 들어가고 도메인 객체가 소유한 데이터는 도메인 객체가 제공하는 행위에 의해 은닉된다.

그럼 서비스는 무엇을 하는가?

서비스는 비즈니스 유스케이스를 구현하기 위해 서비스의 행위를 도메인 객체에 일부분 위임하여 처리한다.

이렇게 서비스의 책임이 도메인으로 적절히 분산되기 때문에 서비스가 비대해지지 않고 서비스는 얇아진다. 또한 각기 적절한 책임을 가지는 클래스로 구성되기 때문에 테스트도 용이하다. 

따라서 도메인 모델 패턴은 비즈니스 로직이 도메인 객체 내에서 중앙 집중화되도록 하여 시스템을 모듈화하고 유지 보수하기 쉽게 만든다.

## 애그리거트 패턴

도메인 모델은 때론 객체 간의 관계를 참조로 표현하는데 도메인이 복잡해지면 다단계 계층 구조가 생기고 참조관계가 복잡해지고 무거워질 수 있다.

이를 보완하기 위한 개념이 바로 애그리거트 패턴이다.

도메인을 개념적으로 묶고 이를 애그리거트라 칭한다.

애그리거트를 한 단위로 일관되게 처리하기 위해 일종의 규칙이 존재하는데 다음과 같다.

* 애그리거트 루트만 참조
* 애그리거트 내 상세 클래스를 바로 참조하지 않고 루트를 통해 참조한다.
* 애그리거트간의 참조는 객체를 직접 참조하지 않고 기본 키를 사용한다.
