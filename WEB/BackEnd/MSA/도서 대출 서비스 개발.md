# 도서 대출 서비스 개발

## 개요

`도메인 주도 설계로 시작하는 마이크로서비스 개발`  
저자 : 한정헌, 유해식, 최은정, 이주영  
출판사 : 위키북스  

위의 책의 공부하며 실습해보려한다.

## 개발 과정

앞의 포스팅에서 JHipster를 이용하여 마이크로 서비스를 생성하고 이들이 어떻게 연결되는지 확인했다.

이제는 책에서의 프로젝트를 따라해보며 서버 기능을 구현해볼 차례이다.

이전 포스팅에서 레지스트리, 게이트웨이, 마이크로 서비스를 구성해봤고 도메인은 도서, 카탈로그, 대출이 있다.

개발 순서는 이렇다.  
1. 내부 아키텍처 결정사항 
2. API 설계
3. 도메인 모델링
4. 도메인 모델링
5. 유스케이스 흐름
6. 내부 영역 개발
7. 외부 영역 개발
8. 단위 테스트

서비스가 수행해야하는 기능에 대해 생각해보면 다음과 같다.

* 사용자는 도서를 대출한다. 도서를 대출하면 도서의 상태가 대출 불가가 된다. 
* 도서를 대출하면 사용자에게 포인트가 적립된다.
* 도서는 대출 기한내에 반납해야한다.
* 도서 대출 기한을 초과하면 연체가 된다.
* 연체가 되면 대출이 불가능해진다.
* 연체되면 연체료를 부과한다.
* 부과된 연체료를 모두 결제해야 대출 불가 처리가 해제된다.

도서 대출 서비스의 일종의 인터페이스인 컨트롤러를 살펴보자

### 도서 대출 API

사용자가 도서 대출신청을 하면 호출되고 요청을 보낸 사용자의 식별 값과 대출하고자하는 도서의 식별값이 전달된다. 

서비스에서는 사용자가 대출 가능한 상태인지 그리고 도서가 대출가능한 상태인지 확인하고 모두 대출 가능한 상태라면 대출이 이루어진다.

`/rentals/{userId}/renteditem/{book}`

대출이 완료되면 처리된 정보를 반환한다.

### 도서 반납 API

`/rentals/{userId}/overdueitem/{book}`

사용자의 userId와 책의 식별값을 이용하여 Rental을 조회해서 반납한다.

요청의 처리가 완료도면 처리된 정보를 반환한다.

### 도서 연체 처리 API

사용자가 대출한 도서를 연체아이템으로 변경할 때 호출되는 API로 연체 처리를 마친 뒤 처리된 도서의 정보를 반환한다. 만약 1권이라도 연체되면 사용자의 도서 대출 상태는 도서대출불가 상태가 되며 연체료가 발생한다.

`/rentals/{userId}/overdueitem/{book}`

@PathVariable로 userId가 전달되고 도서 일련번호에 해당하는 book을 전달한다.

이는 userId인 사용자가 빌린 도서 book이 연체처리된다는 것을 의미한다.

### 연체아이템 반납 처리 API

`/rentals/{userId}/overdueitem/{book}`

연체된 도서의 대출이 취소되는 반납처리 API이다.


## 도메인 모델링

애그리거트는 연관된 객체들의 집합을 말한다.

비즈니스를 테이블화하고 정규화하면 특정 데이터베이스에 의존하고 개발자 이외의 사람들이 이해하기 어려워진다. 도메인 모델링의 목적은 누구라도 쉽게 이해할 수 있도록 객체 모델을 만드는 것이라고 한다.

객체를 그 데이터와 데이터를 이용한 기능 처리를 담당하는 로봇이라고 생각하고 모델링을 해야ㅎㄴ다.

사용자의 대출 정보를 보유한 도서대출로봇이 도서관에 존재한다. 이 로봇은 현재 대출한 도서와 연체된 도서, 대출과 반납 이력을 기록한다.

이 로봇은 대출, 반납에 대한 책임을 가지고있고 대출 시 대출 아이템을 대출 메모리에 기억한다. 만약 대출 일자를 넘어서도 반납되지 않으면 연체 메모리에 이동하여 기록하고 이 때 사용자의 대출 가능 여부를 대출 불가 상태로 만들어 이후로는 대출을 거부한다.

도서가 반납되면 로봇은 대출 혹은 연체 메모리에 있던 도서를 반납 메모리로 옮긴다.

대출, 연체 메모리는 반납 시 비워지지만 반납 메모리의 기록은 개인의 대출도서 내역으로 오랫동안 보관된다.

* 도메인 모델에서는 비즈니스 개념을 표현한다.
* 도메인 모델은 애그리거트 루트 엔티티는 Rental, 이와 일대다 관계에있는 대출 아이템, 연체 아이템, 반납 아이템으로 구성된다.
* 모든 사용자는 대출을 위한 Rental엔티티를 하나씩 보유한다. Rental은 대출, 반납, 연체, 연체 아이템 반납, 연체 해제의 책임을 가진다.
* 대출 시 빌린 도서 만큼 대출아이템이 생성되고 연체되면 이를 연체 아이템으로 이동시키고 반납시 반납 아이템으로 이동시킨다.
* 대출시 개인당 일정 갯수의 대출한도가 체크되고 1권이라도 연체된다면 더는 대출할 수 없다. 이는 enum타입의 RentalStatus에 의해 구분된다.

## 내부 영역 개발

도메인 모델 Rentaldms 사용자의 식별 값, 대출 가능 상태, 연체료, 대출 아이템, 연체 아이템, 반납 아이템의 속성을 가지고있다.

### 엔티티 작성

```java
@Entity
@Table(name = "rental")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
@Data
public class Rental implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    @Column(name = "user_id")
    private Long userId;

    @Enumerated(EnumType.STRING)
    @Column(name = "rental_status")
    private RentalStatus rentalStatus;

    @Column(name="late_fee")
    private Long lateFee;

    @OneToMany(mappedBy = "rental", cascade = CascadeType.ALL, orphanRemoval = true)
    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
    private Set<RentedItem> rentedItems = new HashSet<>();

    @OneToMany(mappedBy = "rental", cascade = CascadeType.ALL, orphanRemoval = true)
    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
    private Set<OverdueItem> overdueItems = new HashSet<>();

    @OneToMany(mappedBy = "rental", cascade = CascadeType.ALL, orphanRemoval = true)
    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
    private Set<ReturnedItem> returnedItems = new HashSet<>();
```
### 대출 메서드 작성

```java
public static Rental createRental(Long userId) {
        Rental rental = new Rental();
        rental.setUserId(userId);
        rental.setRentalStatus(RentalStatus.RENT_AVAILABLE);
        rental.setLateFee(0L);
        return rental;
    }
```

createRental은 rental의 내부에서 사용자의 식별 값만 받아서 생성하고 나머지는 디폴트 값으로 설정한다.

다음으론 대출 가능 여부를 체크하는 로직을 구현한다.

### 대출 가능 여부 체크 메서드 작성
```java
public boolean checkRentalAvailable() throws Exception {
        if(this.rentalStatus.equals(RentalStatus.RENT_UNAVAILABLE) || this.getLateFee()!=0) {
            throw new RuntimeException();
        }
        if (this.getRentedItems().size() > 5) {
            throw new RuntimeException();
        }
        return true;
    }
```

대출이 불가능한 경우는 대출불가능 상태인 경우와 연체료가 존재하는 경우, 그리고 이미 5권의 책을 대출하고있는 경우이다.

### 대출 처리 메서드 작성

```java
public Rental rentBook(Long bookId, String title) {
        this.addRentedItem(RentedItem.createRentedItem(bookId, title, LocalDate.now()));
        return this;
    }
```

대출 완료시 대출정보로 RentedItem 객체를 생성하고 Rental에 추가한다.

### 반납 처리 메서드 작성

```java
   public Rental returnBook(Long bookId) {
       RentedItem rentedItem = this.rentedItems
           .stream()
           .filter(item -> item.getBookId().equals(bookId)).findFirst().get();
       this.addReturnedItem(ReturnedItem.createReturnedItem(
           rentedItem.getBookId(), rentedItem.getBookTitle(), LocalDate.now()
       ));
       this.removeRentedItem(rentedItem);
       return this;
   }
```

반납 완료 시 도서의 일련번호로 Rental에 존재하는 RentedItem을 찾아서 삭제하고 이 정보로 ReturnedItem을 생성한 뒤 Rental에 추가한다.

### RentedItem

```java
@Entity
@Table(name = "rented_item")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
@Data
public class RentedItem implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    @Column(name = "book_id")
    private Long bookId;

    @Column(name = "rented_date")
    private LocalDate rentedDate;

    @Column(name = "due_date")
    private LocalDate dueDate;
    @Column(name = "book_title")
    private String bookTitle;

    @ManyToOne(fetch = FetchType.LAZY)
    @JsonIgnoreProperties("rentedItems")
    private Rental rental;
```

```java
public static RentedItem createRentedItem(Long bookId, String bookTitle, LocalDate rentedDate) {
        RentedItem rentedItem = new RentedItem();
        rentedItem.setBookId(bookId);
        rentedItem.setBookTitle(bookTitle);
        rentedItem.setRentedDate(rentedDate);
        rentedItem.setDueDate(rentedDate.plusWeeks(2));
        return rentedItem;
    }
```

대출시 대출된 도서의 식별 값과 도서명, 빌린 날짜, 2주의 대출 기한을 설정한다.

### ReturnedItem

```java
@Entity
@Table(name = "returned_item")
@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
@Data
public class ReturnedItem implements Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name="book_id")
    private Long bookId;
    @Column(name="returned_date")
    private LocalDate returnedDate;

    @Column(name="book_title")
    private String bookTitle;

    @ManyToOne
    @JsonIgnoreProperties("rentedItems")
    private Rental rental;

    public static ReturnedItem createReturnedItem(Long bookId, String bookTitle, LocalDate now) {
        ReturnedItem returnedItem = new ReturnedItem();
        returnedItem.setBookId(bookId);
        returnedItem.setBookTitle(bookTitle);
        returnedItem.setReturnedDate(now);
        return returnedItem;
    }
```

ReturnedItem은 반납된 도서를 의미하며 반납 아이템 식별 값, 대출한 도서의 식별 값, 반납 일자, 대출 도서명을 가진다.

```java
public static ReturnedItem createReturnedItem(Long bookId, String bookTitle, LocalDate now) {
        ReturnedItem returnedItem = new ReturnedItem();
        returnedItem.setBookId(bookId);
        returnedItem.setBookTitle(bookTitle);
        returnedItem.setReturnedDate(now);
        return returnedItem;
    }
```

```java
public enum RentalStatus {
    RENT_AVAILABLE(0, "대출가능", "대출가능상태"),
    RENT_UNAVAILABLE(1, "대출불가", "대출불가능상태");

    private Integer id;
    private String title;
    private String description;

    RentalStatus(Integer id, String title, String description) {
        this.id = id;
        this.title = title;
        this.description = description;
    }

    public Integer getId() {
        return id;
    }

    public String getTitle() {
        return title;
    }

    public String getDescription() {
        return description;
    }
}
```
## 내부 영역 - 서비스 개발

도서 대출과 반납은 핵심 비즈니스 로직으로 서비스 구현체에서는 이 외의 비즈니스 흐름을 처리하는 역할을 한다.

DDD에서는 서비스를 도메인 서비스와 애플리케이션 서비스로 구분한다. 도메인 서비스는 엔티티에서 수행하기가 부자연스러운 행동을 처리한다.

### 도서 대출 처리 구현

```java
@Override
    @Transactional
    public Rental rentBook(Long userId, Long bookId, String bookTitle) throws Exception {
        Rental rental = rentalRepository.findByUserId(userId).get();
        rental.checkRentalAvailable();
        rental = rental.rentBook(bookId, bookTitle);
        rentalRepository.save(rental);

        rentalProducer.updateBookStatus(bookId, "UNAVAILABLE");
        rentalProducer.updateBookCatalog(bookId, "RENT_BOOK");
        rentalProducer.savePoints(userId);

        return rental;
    }
```
1. Rental을 조회한다.
2. 대출 가능 상태인지 확인하고 Rental에 대출 처리를 위임한다.
3. Rental을 저장한다.
4. 다른 마이크로 서비스인 도서 서비스에 도서 재고 감소 처리를 위해 도서 대출 이벤트를 발행한다.
5. 도서 카탈로그 서비스에 대출된 도서로 상태를 변경하는 이벤트를 발행한다.
6. 포인트 적립을 위해 사용자 서비스에 이벤트를 발송한다.

### 도서 반납 처리 구현

```java
@Override
@Transactional
public Rental returnBooks(Long userId, Long bookId) {
    Rental rental = rentalRepository.findByUserId(userId).get();
    rental = rental.returnbook(bookId);
    rental = rentalRepository.save(rental);

    rentalProducer.updateBookStatus(bookId, "AVAILABLE");
    rentalProducer.updateBookCatalogStatus(bookId, "RETURN_BOOK");

    return rental;
}
```

1. 반납 아이템 조회
2. Rental에 반납 처리 위임
3. Rental 저장
4. 도서 서비스에 재고 증가를 요청하기 위해 도서반납 이벤트 발행
5. 카탈로그 서비스에 대출 가능한 도서로 변경하도록 이벤트 발행

이렇게 서비스 구현체가 특정 기능을 하기 위해서 도메인 모델에 책임을 위임하고 이 것을 레포지토리를 통해 저장한다.

또한 내부 영역의 기능은 서비스 인터페이스로 외부 영역에 공개되고 내부 영역은 특정 기술이 개입되지 않기 때문에 특정 기술에 대한 이해없이도 해당 업무를 이해할 수 있게 된다.

## 외부 영역

이렇게 구현된 기능들은 API로 외부에 공개되어 프론트엔드에서 활용되어야한다. REST 컨트롤러는 구현된 서비스의 REST API를 발행한다.

이는 프론트엔드에 제공할 API를 내부 영역의 도메인을 활용해 적절히 제공되어야한다. 따라서 API 변환 외의 비즈니스 로직 처리는 내부 여역의 서비스 구현체에 위임해야한다.

대출 서비스의 REST 컨트롤러인 RentalResource에서는 도서 대출 API임을 알 수 있는 경로와 표준메소드를 선언하여 제공하고 주요 로직에 대한 처리는 RentalService의 rentBook을 호출하여 위임한다.

도서 대출은 HTTP POST 메소드를 동해 사용자의 식별 값과 대출할 도서의 식별 값을 받는다.

이 식별 값으로 도서 서비스를 동기 호출하여 도서가 대출 가능한 상태인지 검증하고 대출할 도서의 세부 정보를 가져온다.

내부 영역의 서비스를 호출해서 도서 대출을 수행한다.

도서 대출을 처리한 Rental정보를 DTO로 변경하여 HTTP요청의 본문 정보로 담아 클라이언트에 반환한다.

## 외부 영역 - 아웃바운드 어댑터 개발

도서 대출 REST 컨트롤러는 도서 정보를 검증하고 상세 정보를 요청하기위해 도서 서비스에 대한 REST 클라이언트를 이용한다.

이를 처리하기 위한 패키지로 adaptor 패키지를 생성하고 해당 패키지에서 처리하도록 한다.

도서 대출을 완료했을 때 도서 서비스를 대상으로 도서 상태 변경을 요청해야하고 도서 카탈로그 서비스에서 해당 도서가 대출 중임을 나타내는 처리를 해야한다.

이를 위해 아웃바운드 비동기 어댑터를 통해 메시지 이벤트를 전송한다.

페인 라이브러리를 통해 동기 메시지를 호출하고 카프카 메시지 큐를 활용하여 비동기 메시지를 전송한다.

### 페인 클라이언트

페인은 REST 기반의 동기 서비스 호출을 추상화한 Spring Cloud Netflix 라이브러리이다.

이를 이용하여 인터페이스만 구현하면 구체 클라이언트를 생성해주고 스프링이 런타임 시점에 구현체를 제공한다.

```java
@FeignClient(name= "book", configuration = {FeignConfiguration.class})
public interface BookClient {
    @GetMapping("/api/books/bookinfo/{bookId}")
    ResponseEntity<BookInfoDTO> findBookInfo(@PathVariable("bookId")Long bookId);

}
```

이렇게 메소드를 작성하고 bookId를 보내면 도서 서비스의 REST API를 호출하여 해당 객체를 반환한다. 

이렇게 작성하고 BookClient를 RentalResource에서 사용하기 위해 선언해준다.

```java
@PostMapping("/rentals/{userId}/renteditem/{book}")
    public ResponseEntity<RentalDTO> rentBooks(@PathVariable("userid") Long userid, @PathVariable("book") Long bookId)
        throws InterruptedException, ExecutionException, JsonProcessingException, RentUnavailableException {
        log.debug("rent book request");

        ResponseEntity<BookInfoDTO> bookInfoResult = bookClient.findBookInfo(bookId); //feign - 책 정보 가져오기
        BookInfoDTO bookInfoDTO = bookInfoResult.getBody();
        log.debug("book info list", bookInfoDTO.toString());

        Rental rental= rentalService.rentBook(userid, bookInfoDTO.getId(), bookInfoDTO.getTitle());
        RentalDTO rentalDTO = rentalMapper.toDto(rental);
        return ResponseEntity.ok().body(rentalDTO);
    }
```

`ResponseEntity<BookInfoDTO> bookInfoResult = bookClient.findBookInfo(bookId);`

이 부분이 바로 도서 서비스를 호출하여 응답을 받아오는 부분이다.

그런 다음 도서 서비스에서 이에 응답하는 작업이 필요하다.

도서 서비스의 BookResource에 대출 서비스에서 작성한 것과 동힐한 메소드를 작성해준다.

```java
@GetMapping("/books/bookinfo/{bookId}")
    public ResponseEntity<BookInfoDTO> findBookInfo(@PathVariable("bookId") Long bookId){
        Book book = bookService.findBookInfo(bookId);
        BookInfoDTO bookInfoDTO = new BookInfoDTO(bookId, book.getTitle());
        log.debug(bookInfoDTO.toString());
        return ResponseEntity.ok().body(bookInfoDTO);
    }
```

이렇게 서로 연관되어있는 서비스에서 DTO를 사용해야하므로 양 서비스에 모두 같은 BookInfoDTO를 작성해주어야한다.

페인 클라이언트를 처리하기 위해 main메소드가 있는 RentalApp에 @EnableFeignClients 애노테이션을 붙여준다.

## 외부 영역 - 비동기 호출 EDA 구현

대출 서비스에서 도서 대출과 반납을 진행한 뒤 결과에 따라 도서 서비스에서는 해당 도서의 상태를 대출 불가능 혹은 대출 가능으로 변경해야한다.

서비스가 분리되어있는 상태에서 도메인 이벤트를 비동기 통신으로 전송해 비즈니스 일관성을 맞춰준다.

이렇게 시스템은 각기 독립성을 유지하면서 다른 서비스의 이벤트 변화를 기반으로 각 서비스를 연계해서 구성하는 것을 이벤트 기반 아키텍처라고 한다.

이벤트 메시지를 전송할 때 응답이 없는 비동기 메시지 처리 메커니즘의 신뢰성을 보장하려면 메시지 큐가 필요하다. 이럴 경우 카프카를 사용할 수 있다.

## 대출 서비스에 카프카 Producer 만들기

RentalProducer는 아웃바운드 어댑터 이터페이스로 서비스가 어댑터를 직접 호출하지 않도록 추상화된 클래스이다. RentalProducerImpl는 아웃바운드 어댑터 구현체로 도메인 이벤트를 카프카 메시지로 전환하여 발송한다.

현재 비동기 이벤트를 발행해야하는 경우는 
1. 도서 서비스의 도서 상태를 변경
2. 유저 서비스의 포인트 적립
3. 카탈로그 서비스의 도서상태 변경

카프카의 메시지 교환 통로가 되는 토픽은 발행하는 쪽과 받는 쪽의 토픽을 동일하게 맞추면 각 토픽에 해당하는 메시지를 받게 된다.

도서 대출 시 도서 서비스의 대출가능 상태를 변경하기 위해 updateBookStatus 메소드를 통해 StockChanged 도메인 이벤트를 생성하고 메시지를 보낸다. 

포인트 적립은 PointChanged 이벤트를 생성해서 메시지로 변경한 후 전송한다.






