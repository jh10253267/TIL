# 도서 대출 서비스 개발

## 개요

`도메인 주도 설계로 시작하는 마이크로서비스 개발`  
저자 : 한정헌, 유해식, 최은정, 이주영  
출판사 : 위키북스  

위의 책의 공부하며 실습해보려한다.

## 개발 과정

앞의 포스팅에서 JHipster를 이용하여 마이크로 서비스를 생성하고 이들이 어떻게 연결되는지 확인했다.

이제는 책에서의 프로젝트를 따라해보며 서버 기능을 구현해볼 차례이다.

이전 포스팅에서 레지스트리, 게이트웨이, 마이크로 서비스를 구성해봤고 도메인은 도서, 카탈로그, 대출이 있다.

개발 순서는 이렇다.  
1. 내부 아키텍처 결정사항 
2. API 설계
3. 도메인 모델링
4. 도메인 모델링
5. 유스케이스 흐름
6. 내부 영역 개발
7. 외부 영역 개발
8. 단위 테스트

서비스가 수행해야하는 기능에 대해 생각해보면 다음과 같다.

* 사용자는 도서를 대출한다. 도서를 대출하면 도서의 상태가 대출 불가가 된다. 
* 도서를 대출하면 사용자에게 포인트가 적립된다.
* 도서는 대출 기한내에 반납해야한다.
* 도서 대출 기한을 초과하면 연체가 된다.
* 연체가 되면 대출이 불가능해진다.
* 연체되면 연체료를 부과한다.
* 부과된 연체료를 모두 결제해야 대출 불가 처리가 해제된다.

도서 대출 서비스의 일종의 인터페이스인 컨트롤러를 살펴보자

### 도서 대출 API

사용자가 도서 대출신청을 하면 호출되고 요청을 보낸 사용자의 식별 값과 대출하고자하는 도서의 식별값이 전달된다. 

서비스에서는 사용자가 대출 가능한 상태인지 그리고 도서가 대출가능한 상태인지 확인하고 모두 대출 가능한 상태라면 대출이 이루어진다.

`/rentals/{userId}/renteditem/{book}`

대출이 완료되면 처리된 정보를 반환한다.

### 도서 반납 API

`/rentals/{userId}/overdueitem/{book}`

사용자의 userId와 책의 식별값을 이용하여 Rental을 조회해서 반납한다.

요청의 처리가 완료도면 처리된 정보를 반환한다.

### 도서 연체 처리 API

사용자가 대출한 도서를 연체아이템으로 변경할 때 호출되는 API로 연체 처리를 마친 뒤 처리된 도서의 정보를 반환한다. 만약 1권이라도 연체되면 사용자의 도서 대출 상태는 도서대출불가 상태가 되며 연체료가 발생한다.

`/rentals/{userId}/overdueitem/{book}`

@PathVariable로 userId가 전달되고 도서 일련번호에 해당하는 book을 전달한다.

이는 userId인 사용자가 빌린 도서 book이 연체처리된다는 것을 의미한다.

### 연체아이템 반납 처리 API

`/rentals/{userId}/overdueitem/{book}`

연체된 도서의 대출이 취소되는 반납처리 API이다.


## 도메인 모델링

애그리거트는 연관된 객체들의 집합을 말한다.

비즈니스를 테이블화하고 정규화하면 특정 데이터베이스에 의존하고 개발자 이외의 사람들이 이해하기 어려워진다. 도메인 모델링의 목적은 누구라도 쉽게 이해할 수 있도록 객체 모델을 만드는 것이라고 한다.

객체를 그 데이터와 데이터를 이용한 기능 처리를 담당하는 로봇이라고 생각하고 모델링을 해야ㅎㄴ다.

사용자의 대출 정보를 보유한 도서대출로봇이 도서관에 존재한다. 이 로봇은 현재 대출한 도서와 연체된 도서, 대출과 반납 이력을 기록한다.

이 로봇은 대출, 반납에 대한 책임을 가지고있고 대출 시 대출 아이템을 대출 메모리에 기억한다. 만약 대출 일자를 넘어서도 반납되지 않으면 연체 메모리에 이동하여 기록하고 이 때 사용자의 대출 가능 여부를 대출 불가 상태로 만들어 이후로는 대출을 거부한다.

도서가 반납되면 로봇은 대출 혹은 연체 메모리에 있던 도서를 반납 메모리로 옮긴다.

대출, 연체 메모리는 반납 시 비워지지만 반납 메모리의 기록은 개인의 대출도서 내역으로 오랫동안 보관된다.

* 도메인 모델에서는 비즈니스 개념을 표현한다.
* 도메인 모델은 애그리거트 루트 엔티티는 Rental, 이와 일대다 관계에있는 대출 아이템, 연체 아이템, 반납 아이템으로 구성된다.
* 모든 사용자는 대출을 위한 Rental엔티티를 하나씩 보유한다. Rental은 대출, 반납, 연체, 연체 아이템 반납, 연체 해제의 책임을 가진다.
* 대출 시 빌린 도서 만큼 대출아이템이 생성되고 연체되면 이를 연체 아이템으로 이동시키고 반납시 반납 아이템으로 이동시킨다.
* 대출시 개인당 일정 갯수의 대출한도가 체크되고 1권이라도 연체된다면 더는 대출할 수 없다. 이는 enum타입의 RentalStatus에 의해 구분된다.

## 내부 영역 개발

도메인 모델 Rentaldms 사용자의 식별 값, 대출 가능 상태, 연체료, 대출 아이템, 연체 아이템, 반납 아이템의 속성을 가지고있다.

### 엔티티 작성

```java
@Entity
@Table(name = "rental")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
@Data
public class Rental implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    @Column(name = "user_id")
    private Long userId;

    @Enumerated(EnumType.STRING)
    @Column(name = "rental_status")
    private RentalStatus rentalStatus;

    @Column(name="late_fee")
    private Long lateFee;

    @OneToMany(mappedBy = "rental", cascade = CascadeType.ALL, orphanRemoval = true)
    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
    private Set<RentedItem> rentedItems = new HashSet<>();

    @OneToMany(mappedBy = "rental", cascade = CascadeType.ALL, orphanRemoval = true)
    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
    private Set<OverdueItem> overdueItems = new HashSet<>();

    @OneToMany(mappedBy = "rental", cascade = CascadeType.ALL, orphanRemoval = true)
    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
    private Set<ReturnedItem> returnedItems = new HashSet<>();
```
### 대출 메서드 작성

```java
public static Rental createRental(Long userId) {
        Rental rental = new Rental();
        rental.setUserId(userId);
        rental.setRentalStatus(RentalStatus.RENT_AVAILABLE);
        rental.setLateFee(0L);
        return rental;
    }
```

createRental은 rental의 내부에서 사용자의 식별 값만 받아서 생성하고 나머지는 디폴트 값으로 설정한다.

다음으론 대출 가능 여부를 체크하는 로직을 구현한다.

### 대출 가능 여부 체크 메서드 작성
```java
public boolean checkRentalAvailable() throws Exception {
        if(this.rentalStatus.equals(RentalStatus.RENT_UNAVAILABLE) || this.getLateFee()!=0) {
            throw new RuntimeException();
        }
        if (this.getRentedItems().size() > 5) {
            throw new RuntimeException();
        }
        return true;
    }
```

대출이 불가능한 경우는 대출불가능 상태인 경우와 연체료가 존재하는 경우, 그리고 이미 5권의 책을 대출하고있는 경우이다.

### 대출 처리 메서드 작성

```java
public Rental rentBook(Long bookId, String title) {
        this.addRentedItem(RentedItem.createRentedItem(bookId, title, LocalDate.now()));
        return this;
    }
```

대출 완료시 대출정보로 RentedItem 객체를 생성하고 Rental에 추가한다.

### 반납 처리 메서드 작성

```java
   public Rental returnBook(Long bookId) {
       RentedItem rentedItem = this.rentedItems
           .stream()
           .filter(item -> item.getBookId().equals(bookId)).findFirst().get();
       this.addReturnedItem(ReturnedItem.createReturnedItem(
           rentedItem.getBookId(), rentedItem.getBookTitle(), LocalDate.now()
       ));
       this.removeRentedItem(rentedItem);
       return this;
   }
```

반납 완료 시 도서의 일련번호로 Rental에 존재하는 RentedItem을 찾아서 삭제하고 이 정보로 ReturnedItem을 생성한 뒤 Rental에 추가한다.

### RentedItem

```java
@Entity
@Table(name = "rented_item")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
@Data
public class RentedItem implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    @Column(name = "book_id")
    private Long bookId;

    @Column(name = "rented_date")
    private LocalDate rentedDate;

    @Column(name = "due_date")
    private LocalDate dueDate;
    @Column(name = "book_title")
    private String bookTitle;

    @ManyToOne(fetch = FetchType.LAZY)
    @JsonIgnoreProperties("rentedItems")
    private Rental rental;
```

```java
public static RentedItem createRentedItem(Long bookId, String bookTitle, LocalDate rentedDate) {
        RentedItem rentedItem = new RentedItem();
        rentedItem.setBookId(bookId);
        rentedItem.setBookTitle(bookTitle);
        rentedItem.setRentedDate(rentedDate);
        rentedItem.setDueDate(rentedDate.plusWeeks(2));
        return rentedItem;
    }
```

대출시 대출된 도서의 식별 값과 도서명, 빌린 날짜, 2주의 대출 기한을 설정한다.

### ReturnedItem

```java
@Entity
@Table(name = "returned_item")
@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
@Data
public class ReturnedItem implements Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name="book_id")
    private Long bookId;
    @Column(name="returned_date")
    private LocalDate returnedDate;

    @Column(name="book_title")
    private String bookTitle;

    @ManyToOne
    @JsonIgnoreProperties("rentedItems")
    private Rental rental;

    public static ReturnedItem createReturnedItem(Long bookId, String bookTitle, LocalDate now) {
        ReturnedItem returnedItem = new ReturnedItem();
        returnedItem.setBookId(bookId);
        returnedItem.setBookTitle(bookTitle);
        returnedItem.setReturnedDate(now);
        return returnedItem;
    }
```

ReturnedItem은 반납된 도서를 의미하며 반납 아이템 식별 값, 대출한 도서의 식별 값, 반납 일자, 대출 도서명을 가진다.

```java
public static ReturnedItem createReturnedItem(Long bookId, String bookTitle, LocalDate now) {
        ReturnedItem returnedItem = new ReturnedItem();
        returnedItem.setBookId(bookId);
        returnedItem.setBookTitle(bookTitle);
        returnedItem.setReturnedDate(now);
        return returnedItem;
    }
```

```java
public enum RentalStatus {
    RENT_AVAILABLE(0, "대출가능", "대출가능상태"),
    RENT_UNAVAILABLE(1, "대출불가", "대출불가능상태");

    private Integer id;
    private String title;
    private String description;

    RentalStatus(Integer id, String title, String description) {
        this.id = id;
        this.title = title;
        this.description = description;
    }

    public Integer getId() {
        return id;
    }

    public String getTitle() {
        return title;
    }

    public String getDescription() {
        return description;
    }
}
```
## 내부 영역 - 서비스 개발

도서 대출과 반납은 핵심 비즈니스 로직으로 서비스 구현체에서는 이 외의 비즈니스 흐름을 처리하는 역할을 한다.

DDD에서는 서비스를 도메인 서비스와 애플리케이션 서비스로 구분한다. 도메인 서비스는 엔티티에서 수행하기가 부자연스러운 행동을 처리한다.

### 도서 대출 처리 구현

```java
@Override
    @Transactional
    public Rental rentBook(Long userId, Long bookId, String bookTitle) throws Exception {
        Rental rental = rentalRepository.findByUserId(userId).get();
        rental.checkRentalAvailable();
        rental = rental.rentBook(bookId, bookTitle);
        rentalRepository.save(rental);

        rentalProducer.updateBookStatus(bookId, "UNAVAILABLE");
        rentalProducer.updateBookCatalog(bookId, "RENT_BOOK");
        rentalProducer.savePoints(userId);

        return rental;
    }
```
1. Rental을 조회한다.
2. 대출 가능 상태인지 확인하고 Rental에 대출 처리를 위임한다.
3. Rental을 저장한다.
4. 다른 마이크로 서비스인 도서 서비스에 도서 재고 감소 처리를 위해 도서 대출 이벤트를 발행한다.
5. 도서 카탈로그 서비스에 대출된 도서로 상태를 변경하는 이벤트를 발행한다.
6. 포인트 적립을 위해 사용자 서비스에 이벤트를 발송한다.

### 도서 반납 처리 구현

```java
@Override
@Transactional
public Rental returnBooks(Long userId, Long bookId) {
    Rental rental = rentalRepository.findByUserId(userId).get();
    rental = rental.returnbook(bookId);
    rental = rentalRepository.save(rental);

    rentalProducer.updateBookStatus(bookId, "AVAILABLE");
    rentalProducer.updateBookCatalogStatus(bookId, "RETURN_BOOK");

    return rental;
}
```

1. 반납 아이템 조회
2. Rental에 반납 처리 위임
3. Rental 저장
4. 도서 서비스에 재고 증가를 요청하기 위해 도서반납 이벤트 발행
5. 카탈로그 서비스에 대출 가능한 도서로 변경하도록 이벤트 발행

이렇게 서비스 구현체가 특정 기능을 하기 위해서 도메인 모델에 책임을 위임하고 이 것을 레포지토리를 통해 저장한다.

또한 내부 영역의 기능은 서비스 인터페이스로 외부 영역에 공개되고 내부 영역은 특정 기술이 개입되지 않기 때문에 특정 기술에 대한 이해없이도 해당 업무를 이해할 수 있게 된다.

## 외부 영역

이렇게 구현된 기능들은 API로 외부에 공개되어 프론트엔드에서 활용되어야한다. REST 컨트롤러는 구현된 서비스의 REST API를 발행한다.

이는 프론트엔드에 제공할 API를 내부 영역의 도메인을 활용해 적절히 제공되어야한다. 따라서 API 변환 외의 비즈니스 로직 처리는 내부 여역의 서비스 구현체에 위임해야한다.

대출 서비스의 REST 컨트롤러인 RentalResource에서는 도서 대출 API임을 알 수 있는 경로와 표준메소드를 선언하여 제공하고 주요 로직에 대한 처리는 RentalService의 rentBook을 호출하여 위임한다.

도서 대출은 HTTP POST 메소드를 동해 사용자의 식별 값과 대출할 도서의 식별 값을 받는다.

이 식별 값으로 도서 서비스를 동기 호출하여 도서가 대출 가능한 상태인지 검증하고 대출할 도서의 세부 정보를 가져온다.

내부 영역의 서비스를 호출해서 도서 대출을 수행한다.

도서 대출을 처리한 Rental정보를 DTO로 변경하여 HTTP요청의 본문 정보로 담아 클라이언트에 반환한다.

## 외부 영역 - 아웃바운드 어댑터 개발

도서 대출 REST 컨트롤러는 도서 정보를 검증하고 상세 정보를 요청하기위해 도서 서비스에 대한 REST 클라이언트를 이용한다.

이를 처리하기 위한 패키지로 adaptor 패키지를 생성하고 해당 패키지에서 처리하도록 한다.

도서 대출을 완료했을 때 도서 서비스를 대상으로 도서 상태 변경을 요청해야하고 도서 카탈로그 서비스에서 해당 도서가 대출 중임을 나타내는 처리를 해야한다.

이를 위해 아웃바운드 비동기 어댑터를 통해 메시지 이벤트를 전송한다.

페인 라이브러리를 통해 동기 메시지를 호출하고 카프카 메시지 큐를 활용하여 비동기 메시지를 전송한다.

### 페인 클라이언트

페인은 REST 기반의 동기 서비스 호출을 추상화한 Spring Cloud Netflix 라이브러리이다.

이를 이용하여 인터페이스만 구현하면 구체 클라이언트를 생성해주고 스프링이 런타임 시점에 구현체를 제공한다.

```java
@FeignClient(name= "book", configuration = {FeignConfiguration.class})
public interface BookClient {
    @GetMapping("/api/books/bookinfo/{bookId}")
    ResponseEntity<BookInfoDTO> findBookInfo(@PathVariable("bookId")Long bookId);

}
```

이렇게 메소드를 작성하고 bookId를 보내면 도서 서비스의 REST API를 호출하여 해당 객체를 반환한다. 

이렇게 작성하고 BookClient를 RentalResource에서 사용하기 위해 선언해준다.

```java
@PostMapping("/rentals/{userId}/renteditem/{book}")
    public ResponseEntity<RentalDTO> rentBooks(@PathVariable("userid") Long userid, @PathVariable("book") Long bookId)
        throws InterruptedException, ExecutionException, JsonProcessingException, RentUnavailableException {
        log.debug("rent book request");

        ResponseEntity<BookInfoDTO> bookInfoResult = bookClient.findBookInfo(bookId); //feign - 책 정보 가져오기
        BookInfoDTO bookInfoDTO = bookInfoResult.getBody();
        log.debug("book info list", bookInfoDTO.toString());

        Rental rental= rentalService.rentBook(userid, bookInfoDTO.getId(), bookInfoDTO.getTitle());
        RentalDTO rentalDTO = rentalMapper.toDto(rental);
        return ResponseEntity.ok().body(rentalDTO);
    }
```

`ResponseEntity<BookInfoDTO> bookInfoResult = bookClient.findBookInfo(bookId);`

이 부분이 바로 도서 서비스를 호출하여 응답을 받아오는 부분이다.

그런 다음 도서 서비스에서 이에 응답하는 작업이 필요하다.

도서 서비스의 BookResource에 대출 서비스에서 작성한 것과 동힐한 메소드를 작성해준다.

```java
@GetMapping("/books/bookinfo/{bookId}")
    public ResponseEntity<BookInfoDTO> findBookInfo(@PathVariable("bookId") Long bookId){
        Book book = bookService.findBookInfo(bookId);
        BookInfoDTO bookInfoDTO = new BookInfoDTO(bookId, book.getTitle());
        log.debug(bookInfoDTO.toString());
        return ResponseEntity.ok().body(bookInfoDTO);
    }
```

이렇게 서로 연관되어있는 서비스에서 DTO를 사용해야하므로 양 서비스에 모두 같은 BookInfoDTO를 작성해주어야한다.

페인 클라이언트를 처리하기 위해 main메소드가 있는 RentalApp에 @EnableFeignClients 애노테이션을 붙여준다.

## 외부 영역 - 비동기 호출 EDA 구현

대출 서비스에서 도서 대출과 반납을 진행한 뒤 결과에 따라 도서 서비스에서는 해당 도서의 상태를 대출 불가능 혹은 대출 가능으로 변경해야한다.

서비스가 분리되어있는 상태에서 도메인 이벤트를 비동기 통신으로 전송해 비즈니스 일관성을 맞춰준다.

이렇게 시스템은 각기 독립성을 유지하면서 다른 서비스의 이벤트 변화를 기반으로 각 서비스를 연계해서 구성하는 것을 이벤트 기반 아키텍처라고 한다.

이벤트 메시지를 전송할 때 응답이 없는 비동기 메시지 처리 메커니즘의 신뢰성을 보장하려면 메시지 큐가 필요하다. 이럴 경우 카프카를 사용할 수 있다.

## 대출 서비스에 카프카 Producer 만들기

RentalProducer는 아웃바운드 어댑터 이터페이스로 서비스가 어댑터를 직접 호출하지 않도록 추상화된 클래스이다. RentalProducerImpl는 아웃바운드 어댑터 구현체로 도메인 이벤트를 카프카 메시지로 전환하여 발송한다.

현재 비동기 이벤트를 발행해야하는 경우는 
1. 도서 서비스의 도서 상태를 변경
2. 유저 서비스의 포인트 적립
3. 카탈로그 서비스의 도서상태 변경

카프카의 메시지 교환 통로가 되는 토픽은 발행하는 쪽과 받는 쪽의 토픽을 동일하게 맞추면 각 토픽에 해당하는 메시지를 받게 된다.

도서 대출 시 도서 서비스의 대출가능 상태를 변경하기 위해 updateBookStatus 메소드를 통해 StockChanged 도메인 이벤트를 생성하고 메시지를 보낸다. 

포인트 적립은 PointChanged 이벤트를 생성해서 메시지로 변경한 후 전송한다.


### 도서 서비스에 컨슈머 어댑터 구현하기

도서 서비스에 adaptor패키지를 생성하고 하위에 BookConsumer클래스를 생성한다.

```java
@Service
public class BookConsumer {
    private final Logger log = LoggerFactory.getLogger(BookConsumer.class);
    private final AtomicBoolean closed = new AtomicBoolean(false);
    public static final String TOPIC ="topic_book";
    private final KafkaProperties kafkaProperties;
    private KafkaConsumer<String, String> kafkaConsumer;
    private BookService bookService;
    private ExecutorService executorService = Executors.newCachedThreadPool();

    public BookConsumer(KafkaProperties kafkaProperties, BookService bookService) {
        this.kafkaProperties = kafkaProperties;
        this.bookService = bookService;
    }
    @PostConstruct
    public void start(){
        log.info("Kafka consumer starting ...");
        this.kafkaConsumer = new KafkaConsumer<>(kafkaProperties.getConsumerProps());
        Runtime.getRuntime().addShutdownHook(new Thread(this::shutdown));
        kafkaConsumer.subscribe(Collections.singleton(TOPIC));
        log.info("Kafka consumer started");

        executorService.execute(()-> {
                try {
                    while (!closed.get()){
                        ConsumerRecords<String, String> records = kafkaConsumer.poll(Duration.ofSeconds(3));
                        for(ConsumerRecord<String, String> record: records){
                            log.info("Consumed message in {} : {}", TOPIC, record.value());
                            ObjectMapper objectMapper = new ObjectMapper();
                            StockChanged stockChanged = objectMapper.readValue(record.value(), StockChanged.class);
                            bookService.processChangeBookState(stockChanged.getBookId(), stockChanged.getBookStatus());
                        }
                    }
                    kafkaConsumer.commitSync();
                }catch (WakeupException e){
                    if(!closed.get()){
                        throw e;
                    }
                }catch (Exception e){
                    log.error(e.getMessage(), e);
                }finally {
                    log.info("kafka consumer close");
                    kafkaConsumer.close();
                }
            }
        );
    }
    public KafkaConsumer<String, String> getKafkaConsumer() {
        return kafkaConsumer;
    }
    public void shutdown() {
        log.info("Shutdown Kafka consumer");
        closed.set(true);
        kafkaConsumer.wakeup();
    }
}
```

컨슈머는 외부에서 들어오는 요청을 처리하는 인바운드 어댑터에 해당한다.

1. 카프카에서 읽은 메시지를 대출 서비스가 보낸 StockChanged 도메인 이벤트로 변환한다.
2. 이 정보를 가지고 도서 서비스를 호출하여 도서의 재고상태를 변경한다.

따라서 대출 서비스와 동일하게 도서 서비스도 StockCahnged를 생성해주어야한다.

대출 발생 -> 대출 서비스에서 아웃 바운드 어댑터를 호출하고 StockChanged 이벤트를 발행한다.  
그 후 도서 서비스의 Consumer에서 해당 이벤트를 받아 내부 BookService를 호출하여 도서의 대출 상태를 변경하여 비즈니스 일관성을 맞춘다.

현재 구조에서는 비동기 어댑터의 인터페이스가 개념적으로 내부 영역으로 비동기 어댑터의 인터페이스를 지킨다면 카프카 외에 다른 어떤 메시지 큐로도 변경될 수 있다.


## 내부 영역 - 도서 연체 및 연체된 도서 반납

```java
public Rental overdueBook(Long bookId) {
        RentedItem rentedItem = this.rentedItems
            .stream()
            .filter(item -> item.getBookId().equals(bookId)).findFirst().get();
        this.addOverdueItem(OverdueItem.createOverdueItem(
            rentedItem.getBookId(),
            rentedItem.getBookTitle(),
            rentedItem.getDueDate()));
        this.removeRentedItem(rentedItem);
        return this;
    }
```
1. RentedItem 메모리에서 외부로부터 전달받은 bookId와 동일한 아이템을 찾는다.
2. OverdueItem(연체 목록)에 추가한다.
3. RentedItem(대출 목록)에서 제거한다.

```java
public Rental returnOverdueBook(Long bookId) {
        OverdueItem overdueItem = this.overdueItems.stream()
            .filter(item -> item.getBookId().equals(bookId)).findFirst().get();
        this.addReturnedItem(ReturnedItem.createReturnedItem(
           overdueItem.getBookId(),
           overdueItem.getBookTitle(),
           LocalDate.now()));
        this.removeOverdueItem(overdueItem);
        return this;
    }
```
1. 도서의 id와 동일한 아이템을 OverdueItem(연체 목록) 메모리에서 찾는다.
2. 이를 RetunredItem에 추가한다.
3. 기존 연체 리스트에서 이를 삭제한다.

```java
public void makeRentUnable() {
        this.setRentalStatus(RentalStatus.RENT_UNAVAILABLE);
        this.setLateFee(this.getLateFee() + 30);
    }
```

1. 한 권이라도 연체되면 대출가능 상태를 "대출불가상태"로 설정하고 연체료에 30포인트를 기록한다.


## 서비스 흐름 처리

서비스 구현체에 도메인 모델에서 정의된 로직을 사용하여 저장소 처리 기능을 구현해 비즈니스 로직의 유스케이스를 구현한다.

```java
@Override
    public Long beOverdueBook(Long rentalId, Long bookId) {
        Rental rental = rentalRepository.findById(rentalId).get();
        rental = rental.overdueBook(bookId);
        rental.makeRentUnable();
        rentalRepository.save(rental);
        return bookId;
    }
```
1. 연체에 해당하는 대출 식별 값을 통해 Rental을 조회한다.
2. 도서 연체 처리를 Rental에 위임하여 처리한다.
3. 해당 Rental의 대출 가능 여부를 대출불가상태로 설정한 뒤 이를 저장한다.

```java
@Override
    public Rental returnOverdueBook(Long userId, Long book) {
        Rental rental = rentalRepository.findByUserId(userId).get();
        rental = rental.returnOverdueBook(book);
        rentalProducer.updateBookStatus(book, "AVAILABLE");
        rentalProducer.updateBookCatalogStatus(book, "RETURN_BOOK");
        return rentalRepository.save(rental);
    }
```

1. 사용자 식별 값에 해당하는 Rental을 조회한다.
2. 연체아이템 반납 처리를 Rental에 위임하여 처리한다.
3. 카프카를 이용한 메시지를 통해 도서 서비스와 도서 카탈로그 서비스에서 도서의 상태를 대출 가능으로 변경한다.
4. 변경 내용을 저장한다.

## 내부 영역 - 대출 불가 해제 처리

```java
public Rental releaseOverdue() {
        this.setLateFee(0L);
        this.setRentalStatus(RentalStatus.RENT_AVAILABLE);
        return this;
    }
```

"대출불가상태"가 해제되는 조건은 사용자가 연체료를 지불했을 때로 "대출불가상태"가 해제될 때 연체료를 0으로 초기화시키고 대출 가능 상태도 "대출가능"으로 수정한다.

이제 서비스 구현체에서 도메인에 구현된 메소드를 적절히 호출하여 처리한다.

"대출불가상태"를 해제할 땐 사용자의 식별값에 해당하는 Rental을 조회하고 Rental의 releaseOverdue 메소드를 호출해서 처리한다. 그런 다음 대출 레포지토리에 변경사항을 저장한다.

```java
@Override
    public Rental releaseOverdue(Long userId) {
        Rental rental = rentalRepository.findByUserId(userId).get();
        rental = rental.releaseOverdue();
        return rentalRepository.save(rental);
    }
```

## 외부 영역 - REST 컨트롤러

동기 이벤트인 userClient를 호출해서 포인트 결제를 처리하고 그 결과에 따라 서비스를 호출하여 위임한다.

```java
@PutMapping("/rentals/release-overdue/user/{userId}")
    public ResponseEntity releaseOverdue(@PathVariable("userId")Long userId) {
        LatefeeDTO latefeeDTO = new LatefeeDTO();
        latefeeDTO.setUserId(userId);
        latefeeDTO.setLatefee(rentalService.findLatefee(userId));
        try{
            userClient.usePoint(latefeeDTO);

        }catch (FeignException.FeignClientException e){
            if (!Integer.valueOf(HttpStatus.NOT_FOUND.value()).equals(e.getStatus())) {
                throw e;
            }
        }
        RentalDTO rentalDTO = rentalMapper.toDto(rentalService.releaseOverdue(userId));
        return ResponseEntity.ok().body(rentalDTO);
    }
```

## 유저 서비스 - 외부 영역 - 아웃바운드 어댑터


필요한 구현은 이렇다.

사용자를 생성하여 저장하고 아웃바운드 어댑터 인터페이스에서 createRental을 호출하여 대출 서비스에 Rental을 생성하도록 비동기 메시지 이벤트를 전송한다.

```java
@Transactional
    public User createUser(AdminUserDTO userDTO) {
        User user = new User();
        user.setLogin(userDTO.getLogin().toLowerCase());
        user.setFirstName(userDTO.getFirstName());
        user.setLastName(userDTO.getLastName());
        if (userDTO.getEmail() != null) {
            user.setEmail(userDTO.getEmail().toLowerCase());
        }
        user.setImageUrl(userDTO.getImageUrl());
        if (userDTO.getLangKey() == null) {
            user.setLangKey(Constants.DEFAULT_LANGUAGE); // default language
        } else {
            user.setLangKey(userDTO.getLangKey());
        }
        String encryptedPassword = passwordEncoder.encode(RandomUtil.generatePassword());
        user.setPassword(encryptedPassword);
        user.setResetKey(RandomUtil.generateResetKey());
        user.setResetDate(Instant.now());
        user.setActivated(true);
        if (userDTO.getAuthorities() != null) {
            Set<Authority> authorities = userDTO.getAuthorities().stream()
                .map(authorityRepository::findById)
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.toSet());
            user.setAuthorities(authorities);
        }
        user.setPoint(1000);
        userRepository.save(user);
        gatewayProducer.createRental(user.getId());
        this.clearUserCaches(user);
        log.debug("Created Information for User: {}", user);
        return user;
    }
```

아웃바운드 어댑터인 GatewayProducer.createRental은 사용자의 아이디 정보를 받아 UserIdCreated라는 도메인 이벤트를 생성하고 대출 서비스가 구독중인 Topic에 카프카 메시지를 전송하고 이 메시지는 대출 서비스의 인바운드 어댑터를 통해 전달되어 Rental엔티티를 생성하게 된다.

## 유저 서비스 - 포인트 관리 기능

### 포인트 부여 기능

사용자가 생성될 때 기본 포인트 1000점을 부과하는 기능을 구현한다.

JHipster에서 구현되어있는 메소드인 registerUser, createUser(회원가입)에 user.setPoint(1000)와 같이 레포지토리에 구현된 로직을 사용한다.

외부에서 비동기 호출에 반응해서 포인트 적립이 이뤄지고 외부에서의 동기 호출에 의해 포인트 결제가 이루어진다.

GatewayConsumer에서 포인트 적립 이벤트 메시지에 반응해야한다.

컨슈머 어댑터는 대출 서비스가 전송한 SavePointEvent이벤트를 받아서 userService.savePoint()를 호출하고 사용자의 정보와 적립할 포인트 정보를 전달한다.

```java
public void savePoint(Long userId, int points) {
        User user = userRepository.findById(userId).get();
        user=user.savePoints(points);
        userRepository.save(user);
    }
```

레포지토리에서 찾고 포인트를 적립한 뒤 정보를 레포지토리에 저장한다.

포인트 결제 처리는 포인트 적립과는 다르게 동기 호출에 의해 이루어져야하는데 이는 포인트 결제 처리 결과에 따라 대출 마이크로서비스의 실행 로직이 달라지기 때문이다.

사용자 서비스에서는 외부에서의 비동기 호출에 반응하여 포인트 적립이 이뤄지고 외부에서의 동기 호출에 의해 포인트 결제가 일어난다.

따라서 컨슈머 어댑터인 GatewayConsumer를 통해 포인트 적립 이벤트 메시지에 반응해야한다.

컨슈머 어댑터는 대출 서비스가 전송한 SavePointEvent라는 포인트 적립 이벤트를 받아 userService를 호출하고 사용자의 정보와 적립할 포인트 정보를 전달한다.


```java
@PutMapping("/users/latefee")
    public ResponseEntity usePoint(@RequestBody LatefeeDTO latefeeDTO) throws UsePointsUnavailableException {
        userService.usePoints(latefeeDTO.getUserId(), latefeeDTO.getLatefee());
        return new ResponseEntity<>(HttpStatus.OK);
    }
```

put 방식으로 요청을 받고 LatefeeDTO를 전달받아 내부 영역에 해당하는 userService를 호출하여 해당 DTO에 담긴 사용자 식별 값과 연체료 정보를 전달한다.

```java
public User usePoints(Long userId, int latefee) throws UsePointsUnavailableException {
        User user = userRepository.findById(userId).get();
        user= user.usePoints(latefee);
        return userRepository.save(user);
    }
```

사용자 식별 값을 통해 유저를 조회하고 도메인에 usePoints를 호출하여 일을 위임한다.

만약 연체료 결제에 실패하면 예외를 던지고 성공하면 저장한다.

<img width="473" alt="스크린샷 2024-06-04 오후 3 09 58" src="https://github.com/jh10253267/TIL/assets/108499717/bce77a1c-e2b4-408e-aaab-1eff82ffd213">


포인트 적립은 카프카 컨슈머 어댑터에 의해 비동기 요청을 처리되고 포인트 결제는 REST 동기 요청으로 처리한다.

## CQRS

현재 구조는 기본 도서 정보를 관리하는 도서 서비스와 사용자가 빠르게 검색할 수 있도록 도서 카탈로그 마이크로서비스로 분리했다.

읽기와 명령을 분리하는 CQRS패턴을 

일기 전용 서비스인 도서 카탈로그 서비스에서는 읽기에 최적화된 MongoDB를 저장소로 사용하고 도서 서비스에서는 H2 DB를 사용한다. 만약 도서 서비스에 새로운 도서가 추가되거나 정보가 변경되면 도서 카탈로그 서비스에도 도서 서비스의 변경사항이 반영되어야한다. 

도서 서비스에서 도서 변경사항을 저장한 후 도서 정보 변경 이벤트를 발행하면 도서 카탈로그 서비스가 이벤트를 수신해서 도서 변경사항을 반영해서 도서 정보의 일관성을 맞출 수 있다.

### 구현 기능

* 입고 도서 등록
* 재고 도서 등록
* 재고 도서 변경

새로운 도서를 등록할 때 관련 정보와 함께 등록된다.  
입고된 도서를 대출할 수 있도록 유형을 분류하고 등록한다.  
등록되면 대출 가능한 상태로 등록되고 등록이 완료되면 도서  카탈로그 서비스에서 조회 및 검색되도록 등록 이벤트를 전송한다.  


### 내부 아키텍처

### 내부 영역 - 도메인 모델

도메인 모델 중 입고 도서를 나타내는 InStockBook 클래스와 재고 도서를 나타내는 Book 클래스가 있다.

입고 도서 엔티티는 일련번호, 제목, 설명, 저자, 출판사, ISBN, 출간일 등의 속성을 가지고 있고 입고 출처를 나타내는 Source Enum이 있다.

ISBN의 경우 국제 표준 도서 번호로 여러 의미있는 코드가 모여 문자열을 만든 것으로 값 객체로 선언할 수 있다. 또한, 한 번 생성된 후 변경되지 않는 불변 값이기 때문에 ISBN 유효성 검사 로직이 필요하다.

```java
@Entity
@Table(name = "in_stock_book")
@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
@Data
@ToString
public class InStockBook implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "title")
    private String title;

    @Column(name = "description")
    private String description;

    @Column(name = "author")
    private String author;

    @Column(name = "publisher")
    private String publisher;

    @Column(name = "isbn")
    private Long isbn;

    @Column(name = "publication_date")
    private LocalDate publicationDate;

    @Enumerated(EnumType.STRING)
    @Column(name = "source")
    private Source source;
```

입고된 책의 출처를 나타내는 Enum인 Source는 아래와 같이 구성된다.

기부 받았거나 구매한 책.

```java
public enum Source {
    Donated, Purchased
}
```

재고로 가지고있는 도서의 기본 정보를 담고 있는 도서 엔티티는 Book은 대출 상태와 도서 분류, 보유 도서관 등의 속성을 가진다. 

```java
public enum Classification {
    Arts, Photography, Biographies, BusinessMoney, Children, ComputerTechnology, History, Medical, Travel, Romance, Science, Math, SelfHelp
}
```

```java
public enum Location {
    JEONGJA, PANGYO
}
```

```java
public enum BookStatus {
    AVAILABLE, UNAVAILABLE
}
```

### 내부 영역 - 서비스 개발

내부 영역의 서비스 구현체는 애그리거트 루트 단위로 생성하기 때문에 BookService, InStockBookService 인터페이스가 각각 필요하다.

먼저 BookServicer가 제공해야하는 것은 재고 도서의 검색, 등록, 수정, 삭제다.

```java
void delete(Long id);
Book findBookInfo(Long bookId);
Book registerNewBook(Book book, Long inStockId);
Book updateBook(Book book);
```


```java
@Override
    public void delete(Long id) {
        log.debug("Request to delete Book : {}", id);
        sendBookCatalogEvent("DELETE_BOOK", id);
        bookRepository.deleteById(id);
    }

    @Override
    public Book findBookInfo(Long bookId) {
        return bookRepository.findById(bookId).get();
    }

    @Override
    public Book registerNewBook(Book book, Long inStockId) {
        Book newBook = bookRepository.save(book);
        inStockBookService.delete(inStockId);
        sendBookCatalogEvent("NEW_BOOK", newBook.getId());
        return null;
    }

    @Override
    public Book updateBook(Book book) {
        Book updatedBook = bookRepository.save(book);
        sendBookCatalogEvent("UPDATE_BOOK", book.getId());
        return updatedBook;
    }
```

`sendBookCatalogEvent`와 같이 이벤트를 생성하고 있다.

여기서 registerNewBook 메소드를 보면 입고 도서가 재고 도서로 등록될 때 컨트롤러에서 전달받은 도서 정보를 도서 레포지토리를 통해 저장한 후 이를 입고 도서에서 삭제시키는 로직이 있다.

이렇게 두 개의 독립된 에그리거트 간의 비즈니스 로직을 처리할 필요가 있을 경우 도메인 서비스 객체를 만들 수도 있는데 애플리케이션 서비스인 서비스 구현체가 처리하고있다.

```java
Book book = bookRepository.findById(bookId).get();
        BookChanged bookChanged = new BookChanged();
        if(eventType.equals("NEW_BOOK") || eventType.equals("UPDATE_BOOK")) {
            bookChanged.setBookId(book.getId());
            bookChanged.setAuthor(book.getAuthor());
            bookChanged.setClassification(book.getClassification().toString());
            bookChanged.setDescription(book.getDescription());
            bookChanged.setPublicationDate(book.getPublicationDate().format(fmt));
            bookChanged.setTitle(book.getTitle());
            bookChanged.setEventType(eventType);
            bookChanged.setRented(!book.getBookStatus().equals(BookStatus.AVAILABLE));
            bookChanged.setRentCnt((long) 0);
            bookProducer.sendBookCreateEvent(bookChanged);
        }else if(eventType.equals("DELETE_BOOK")){
            bookChanged.setEventType(eventType);
            bookChanged.setBookId(book.getId());
            bookProducer.sendBookDeleteEvent(bookChanged);
        }
```

재고 도서정보를 조회하고 도서변경됨 이벤트 객체를 생성한다.

신규 재고 도서이거나 재고 도서 수정인 경우 bookProducer를 통해 이벤트 메시지를 전송한다.

만약 삭제인 경우 bookProducer를통해 delete 메시지를 전송한다.

재고 도서 정보 조회 API는 대출 서비스에서 대출을 검증하기 위해 호출된다.

먼저 도서 식별 값을 받고 도서 서비스를 호출하여 조회할 도서를 찾는다.

반환받은 도서 정보 중 도서 식별 값과 도서명을 조합해서 대출 서비스로 반환할 BookInfoDTO를 생성하고 리턴한다.

### 외부 영역 - 아웃바운드 어댑터

도서 서비스로 이벤트를 전송할 때 호출되는 아웃바운드 어댑터를 구현한다.

```java
@Service
public class BookProducerImpl implements BookProducer {
    private final Logger log = LoggerFactory.getLogger(BookProducerImpl.class);

    private static final String TOPIC_CATALOG = "topic_catalog";

    private final KafkaProperties kafkaProperties;

    private final static Logger logger = LoggerFactory.getLogger(BookProducerImpl.class);
    private KafkaProducer<String, String> producer;
    private final ObjectMapper objectMapper = new ObjectMapper();


    public BookProducerImpl(KafkaProperties kafkaProperties) {
        this.kafkaProperties = kafkaProperties;
    }

    @PostConstruct
    public void initialize(){
        log.info("Kafka producer initializing...");
        this.producer = new KafkaProducer<>(kafkaProperties.getProducerProps());
        Runtime.getRuntime().addShutdownHook(new Thread(this::shutdown));
        log.info("Kafka producer initialized");
    }

    public void sendBookCreateEvent(BookChanged bookChanged)throws ExecutionException, InterruptedException, JsonProcessingException{
        String message = objectMapper.writeValueAsString(bookChanged);
        producer.send(new ProducerRecord<>(TOPIC_CATALOG, message)).get();
    }

    public void sendBookDeleteEvent(BookChanged bookDeleteEvent)throws ExecutionException, InterruptedException, JsonProcessingException{
        String message = objectMapper.writeValueAsString(bookDeleteEvent);
        producer.send(new ProducerRecord<>(TOPIC_CATALOG, message)).get();
    }

    @PreDestroy
    public void shutdown(){
        log.info("Shutdown Kafka producer");
        producer.close();
    }
}
```

서비스로부터 전달받은 BookChanged 도메인 이벤트를 카프카 메시지로 변환해서 전송한다. 토픽은 `"topic_catalog"`으로 설정

### 외부 영역 - 인바운드 어댑터

도서가 대출, 반납되면 대출 마이크로 서비스에서 도서 정보의 비동기 메시지를 발송해서 도서 서비스에서 재고 도서 정보의 일관성을 맞춰야한다.

```java
package com.myapp.book.adaptor;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.myapp.book.domain.StockChanged;
import com.myapp.book.service.BookService;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.kafka.KafkaProperties;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.util.Collections;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;

@Service
public class BookConsumer {
    private final Logger log = LoggerFactory.getLogger(BookConsumer.class);
    private final AtomicBoolean closed = new AtomicBoolean(false);
    public static final String TOPIC ="topic_book";
    private final KafkaProperties kafkaProperties;
    private KafkaConsumer<String, String> kafkaConsumer;
    private BookService bookService;
    private ExecutorService executorService = Executors.newCachedThreadPool();

    public BookConsumer(KafkaProperties kafkaProperties, BookService bookService) {
        this.kafkaProperties = kafkaProperties;
        this.bookService = bookService;
    }
    @PostConstruct
    public void start(){
        log.info("Kafka consumer starting ...");
        this.kafkaConsumer = new KafkaConsumer<>(kafkaProperties.getConsumerProps());
        Runtime.getRuntime().addShutdownHook(new Thread(this::shutdown));
        kafkaConsumer.subscribe(Collections.singleton(TOPIC));
        log.info("Kafka consumer started");

        executorService.execute(()-> {
                try {
                    while (!closed.get()){
                        ConsumerRecords<String, String> records = kafkaConsumer.poll(Duration.ofSeconds(3));
                        for(ConsumerRecord<String, String> record: records){
                            log.info("Consumed message in {} : {}", TOPIC, record.value());
                            ObjectMapper objectMapper = new ObjectMapper();
                            StockChanged stockChanged = objectMapper.readValue(record.value(), StockChanged.class);
                            bookService.processChangeBookState(stockChanged.getBookId(), stockChanged.getBookStatus());
                        }
                    }
                    kafkaConsumer.commitSync();
                }catch (WakeupException e){
                    if(!closed.get()){
                        throw e;
                    }
                }catch (Exception e){
                    log.error(e.getMessage(), e);
                }finally {
                    log.info("kafka consumer close");
                    kafkaConsumer.close();
                }
            }
        );
    }
    public KafkaConsumer<String, String> getKafkaConsumer() {
        return kafkaConsumer;
    }
    public void shutdown() {
        log.info("Shutdown Kafka consumer");
        closed.set(true);
        kafkaConsumer.wakeup();
    }
}
```

대출 서비스와 공유하는 토픽명을 설정한다.  
도서 서비스를 호출하여 매개변수로 도서 일련번호와 도서 상태를 전달한다.

```java
bookService.processChangeBookState(stockChanged.getBookId(), stockChanged.getBookStatus());
```

컨슈머 어댑터는 대출 서비스가 발송한 메시지의 토픽을 구독하고 메시지를 받는다.

```java
kafkaConsumer.subscribe(Collections.singleton(TOPIC));
```

이렇게 "topic_book"을 구독하고 메시지가 수신되면 해당 메시지를 ObjectMapper를 통해 StockChanged라는 도메인 이벤트 객체로 변환한다.

```java
@Override
    public void processChangeBookState(Long bookId, String bookStatus) {
        Book book = bookRepository.findById(bookId).get();
        book.setBookStatus(BookStatus.valueOf(bookStatus));
        bookRepository.save(book);
    }
```

도서 인바운드 어댑터에서 호출한 `processChangeBookState`메소드이다.  
매개변수로 도서 식별 값과 도서 상태를 받고 수정 및 저장한다.

<img width="481" alt="스크린샷 2024-06-04 시간: 16 56 13" src="https://github.com/jh10253267/TIL/assets/108499717/c280b126-96df-448a-9986-ef93bfcd0670">


## 도서 카탈로그 서비스

도서 카탈로그는 도서 목록의 조회 및 검색을 위한 읽기 전용 서비스이다. 이와 같은 서비스의 특성상 조회 및 검색 속도가 빠른 NoSQL을 사용한다.

기능으로는 대출 시스템에 존재하는 도서 가운데 대출 횟수가 가장 많은 순으로 정렬하여 리턴한다.

도서 카탈로그는 하나의 엔티티로 구성된다.

조회 및 검색용도이기 때문에 정보를 빠르고 쉽게 확인하는데 필요한 속성들로 구성된다.

여기서 해당 엔티티는 엔티티이자 애그리거트 루트이다.

### 내부 영역 - 도메인 모델 개발


```java
@Document(collection = "book_catalog")
@Data
public class BookCatalog implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    private String id;

    @Field("title")
    private String title;

    @Field("author")
    private String author;

    @Field("publication_date")
    private LocalDate publicationDate;

    @Field("classification")
    private String classification;

    @Field("rented")
    private Boolean rented;

    @Field("description")
    private String description;

    @Field("book_id")
    private Long bookId;

    @Field("rent_cnt")
    private Long rentCnt;
}
```

@Document 애노테이션은 스프링에서 MongoDB를 사용할 때 @Entity 대신 사용하는 애노테이션이다.

해당 클래스는 다른 서비스의 비동기 메시지 요청에 따라 데이터 일관성을 맞추기 위한 생성, 변경 기능을 제공하고 이 기능들은 컨슈머 어댑터에 의해 호출될 것이다.

```java
public static BookCatalog registerNewBookCatalog(BookChanged bookChanged){
        BookCatalog bookCatalog = new BookCatalog();
        bookCatalog.setBookId(bookChanged.getBookId());
        bookCatalog.setAuthor(bookChanged.getAuthor());
        bookCatalog.setClassification(bookChanged.getClassification());
        bookCatalog.setDescription(bookChanged.getDescription());
        bookCatalog.setPublicationDate(LocalDate.parse(bookChanged.getPublicationDate(), DateTimeFormatter.ofPattern("yyyy-MM-dd")));
        bookCatalog.setRented(bookChanged.getRented());
        bookCatalog.setTitle(bookChanged.getTitle());
        bookCatalog.setRentCnt(bookChanged.getRentCnt());
        return bookCatalog;
    }
```

`registerNewBookCatalog`는 새로운 BookCatalog를 생성하는 메소드로 BookChanged 이벤트를 매개변수로 받는다. 내부에서 BookCatalog를 생성한다.

BookChanged에 담긴 정보에 따라 BookCatalog정보를 설정하고 반환한다.

```java
public BookCatalog rentBook(){
        this.setRentCnt(this.getRentCnt()+(long)1);
        this.setRented(true);
        return this;
    }

public BookCatalog returnBook(){
    this.setRented(false);
    return this;
}
```

BookCatalog의 상태를 수정하는 경우는 책을 빌릴 때와 책을 반납할 때이다.

대출 횟수를 1증가시키는 메소드와 상태를 대출 가능으로 수정하는 코드이다.

```java
public BookCatalog updateBookCatalogInfo(BookChanged bookChanged){
        this.setAuthor(bookChanged.getAuthor());
        this.setClassification(bookChanged.getClassification());
        this.setDescription(bookChanged.getDescription());
        this.setPublicationDate(LocalDate.parse(bookChanged.getPublicationDate(), DateTimeFormatter.ofPattern("yyyy-MM-dd")));
        this.setRented(bookChanged.getRented());
        this.setTitle(bookChanged.getTitle());
        this.setRentCnt(bookChanged.getRentCnt());
        return this;
    }
```

도서 카탈로그의 정보를 수정할 때 BookChanged 이벤트를 받아서 해당 내용에 따라 BookCatalog의 정보를 변경한 뒤 리턴한다.


### 내부 영역 - 서비스

```java
@GetMapping("/book-catalogs/top-10")
    public ResponseEntity<List<BookCatalog>> loadTop10Books() {
        List<BookCatalog> bookCatalogs = bookCatalogService.loadTop10();
        return ResponseEntity.ok().body(bookCatalogs);
    }
```

```java
@Override
    public List<BookCatalog> loadTop10() {
        return bookCatalogRepository.findTop10ByOrderByRentCntDesc();
    }
```

```java
@Repository
public interface BookCatalogRepository extends MongoRepository<BookCatalog, String> {
    Page<BookCatalog> findByTitleContaining(String title, Pageable pageable);
    List<BookCatalog> findTop10ByOrderByRentCntDesc();
}
```

### 외부 영역 - 인바운드 어댑터

<img width="444" alt="스크린샷 2024-06-04 시간: 17 32 52" src="https://github.com/jh10253267/TIL/assets/108499717/194e3fc8-a5f5-4809-b9c4-03f7f576b418">


도서 서비스에서 도서를 생성, 수정, 삭제하면 도서 카탈로그 서비스로 이벤트를 발송한다. 대출 서비스에서 도서를 대출, 반납하면 도서 카탈로그 서비스로 도서 상태 변경 이벤트를 발송한다.

이벤트를 보내는 곳과 목적이 다르기 때문에 도서 카탈로그 서비스의 컨슈머 어댑터에서 받는 BookChanged이벤트는 4가지 유형으로 메시지를 수신한 뒤 BookCatalogService를 호출하여 해당 이벤트 종류에 따라 각기 다른 메소드를 실행해서 처리한다.

그리고 도서 카탈로그 서비스는 CQRS패턴이 적용된 조회용 서비스이기 때문에 이벤트 발송 처리가 없다. 따라서 도서 카탈로그 서비스에는 Producer는 없고 Consumer만 존재한다.


```java
@Service
public class BookCatalogConsumer {
    private final Logger log = LoggerFactory.getLogger(BookCatalogConsumer.class);

    private final AtomicBoolean closed = new AtomicBoolean(false);

    public static final String TOPIC ="topic_catalog";

    private final KafkaProperties kafkaProperties;

    private KafkaConsumer<String, String> kafkaConsumer;

    private BookCatalogRepository bookCatalogRepository;

    private ExecutorService executorService = Executors.newCachedThreadPool();

    private static final DateTimeFormatter fmt = DateTimeFormatter.ofPattern("yyyy-MM-dd");

    private final BookCatalogService bookCatalogService;



    public BookCatalogConsumer(KafkaProperties kafkaProperties, BookCatalogRepository bookCatalogRepository, BookCatalogService bookCatalogService) {
        this.kafkaProperties = kafkaProperties;
        this.bookCatalogRepository = bookCatalogRepository;
        this.bookCatalogService = bookCatalogService;
    }

    @PostConstruct
    public void start(){
        log.info("Kafka consumer starting ...");
        this.kafkaConsumer = new KafkaConsumer<>(kafkaProperties.getConsumerProps());
        Runtime.getRuntime().addShutdownHook(new Thread(this::shutdown));
        kafkaConsumer.subscribe(Collections.singleton(TOPIC));
        log.info("Kafka consumer started");

        executorService.execute(()-> {
                try {

                    while (!closed.get()){
                        ConsumerRecords<String, String> records = kafkaConsumer.poll(Duration.ofSeconds(3));
                        for(ConsumerRecord<String, String> record: records){
                            log.info("Consumed message in {} : {}", TOPIC, record.value());
                            ObjectMapper objectMapper = new ObjectMapper();
                            BookChanged bookChanged = objectMapper.readValue(record.value(), BookChanged.class);
                            bookCatalogService.processCatalogChanged(bookChanged);
                        }

                    }
                    kafkaConsumer.commitSync();

                }catch (WakeupException e){
                    if(!closed.get()){
                        throw e;
                    }

                }catch (Exception e){
                    log.error(e.getMessage(), e);
                }finally {
                    log.info("kafka consumer close");
                    kafkaConsumer.close();
                }

            }
        );
    }

    public KafkaConsumer<String, String> getKafkaConsumer() {
        return kafkaConsumer;
    }

    public void shutdown() {
        log.info("Shutdown Kafka consumer");
        closed.set(true);
        kafkaConsumer.wakeup();
    }
}
```


```java
BookChanged bookChanged = objectMapper.readValue(record.value(), BookChanged.class);
bookCatalogService.processCatalogChanged(bookChanged);
```

도서정보 변경 이벤트 생성  
도서 카탈로그 변경 프로세스 진행  

도서 서비스에서 비동기 메시지를 보냈을 때의 Topic과 동일하게 설정한다.

"topic_catalog" 토픽을 수신해서 ObjectMapper를 통해 수신한 카프카 메시지를 BookChanged 도메인 이벤트로 변환하여 메시지를 읽는다.

서비스에서 `processCatalogChanged` 메소드를 호출하여 수신한 BookChanged 도메인 이벤트를 보내 도서 카탈로그의 생성, 수정, 삭제를 위임한다.

해당 서비스 메소드에서는 이벤트 종류별 분기 처리를 담당한다.

```java
@Override
    public void processCatalogChanged(BookChanged bookChanged) {
        String eventType  = bookChanged.getEventType();
        switch (eventType) {
            case "NEW_BOOK":
                registerNewBook(bookChanged);
                break;
            case "DELETE_BOOK":
                deleteBook(bookChanged);
                break;
            case "RENT_BOOK":
            case "RETURN_BOOK":
                updateBookStatus(bookChanged);
                break;
            case "UPDATE_BOOK":
                updateBookInfo(bookChanged);
                break;
        }
    }
```

```java
private BookCatalog registerNewBook(BookChanged bookChanged) {
    BookCatalog bookCatalog = BookCatalog.registerNewBookCatalog(bookChanged);
    bookCatalog= bookCatalogRepository.save(bookCatalog);
    return bookCatalog;
}

private void deleteBook(BookChanged bookChanged) {
    bookCatalogRepository.deleteByBookId(bookChanged.getBookId());
}

private BookCatalog updateBookStatus(BookChanged bookChanged) {
    BookCatalog bookCatalog = bookCatalogRepository.findByBookId(bookChanged.getBookId());
    if(bookChanged.getEventType().equals("RENT_BOOK")) {
        bookCatalog= bookCatalog.rentBook();

    }else if(bookChanged.getEventType().equals("RETURN_BOOK")){
        bookCatalog= bookCatalog.returnBook();

    }
    bookCatalog= bookCatalogRepository.save(bookCatalog);
    return bookCatalog;
}

private BookCatalog updateBookInfo(BookChanged bookChanged) {
    BookCatalog bookCatalog = bookCatalogRepository.findByBookId(bookChanged.getBookId());
    bookCatalog = bookCatalog.updateBookCatalogInfo(bookChanged);
    bookCatalog = bookCatalogRepository.save(bookCatalog);
    return bookCatalog;
}
```

registerNewBook 메소드는 BookChanged의 타입이 새로운 도서일 때 실행되는 메소드로 전달받은 정보를 도메인 객체에 위임하여 도서 카탈로그를 생성하고 레포지토리에 저장한다.

deleteBook 메소드는 타입이 삭제일 때 실행되는 메소드로 카탈로그를 검색하여 삭제한다.

updateBookStatus는 타입이 대출과 반납일 때 실행되고 전달받은 도서 식별값으로 도서 카탈로그를 조회한다. 만약 RENT일 때 도메인 모델의 rentBook을 호출하여 상태를 대출 중으로 변경하고 RETURN일 경우 returnBook 메소드를 호출하여 대출 상태를 대출 가능으로 변경하고 이를 레포지토리를 통해 저장한다.

updateBookInfo는 타입이 UPDATE일 경우 실행하는 메소드로 도서 식벽 값으로 도서 카탈로그 객체를 가져와 수정한 뒤 저장한다.

<img width="490" alt="스크린샷 2024-06-04 시간: 17 50 37" src="https://github.com/jh10253267/TIL/assets/108499717/be0c0b37-d2b4-424c-9eb4-ebfbeb02b263">

외부에 노출된 2개의 REST API가 있고 구독한 메시지 이벤트를 처리할 컨슈머 어댑터가 있다.

### 정리

도서 서비스는 커맨드의 역할을 하고 도서 카탈로그 서비스는 읽기 전용 역할을 한다. 두서비스의 비즈니스 정합성을 맞추기 위해 이벤트 기반의 아키텍처를 적용하고 메시지 큐를 사용한다.

이렇게 두 서비스의 기능과 저장소를 완전히 분리했기 때문에 만약 도서 카탈로그 서비스의 사용량이 증가하면 유연하게 도서 카탈로그 서비스만 확장할 수 있다.