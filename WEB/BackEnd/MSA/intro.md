# Intro

## Amazon

2011년 기준 아마존의 비즈니스 서비스가 배포되는 주기는 11.6초 그리고 2019년 에는 초당 1.5번

비즈니스는 계속 변경되고 이에 따라 개선된 시스템도 계속 배포되어야한다. 그리고 새로운 서비스를 내놓았는데 반응이 좋지 않다면 빠른 시간 안에 개선되어야한다.

우리가 사용하는 서비스는 빌드되고 배포된다. 그 과정에 걸리는 시간은 꽤 길다. 그러나 아마존에선 1.5초마다 변경 및 개선되어 배포되고있다고 하니 엄청난 속도이다.

이것이 가능한 이유는 여러가지가 있겠지만 그중 인프라 스트럭쳐부터 살펴보자.

서버를 도입하고 네트워크를 구축한 뒤 각 서버마다 운영체제를 설치하고 서비스에 필요한 소프트웨어를 설치하는 과정으로 진행되고 이 기간은 며칠에서 몇 달이 걸리기도 한다. 

새로운 서비스 개발을 위한 프로젝트를 시작한다고 했을 때 인프라를 구축하기 위한 초기 투자 비용을 고려해야하고 이것들을 지속적으로 관리하는 비용을 고려해야한다. 그러나 이러한 리스크들은 최근 도입되고있는 클라우드 인프라로 해결되었다. 그 중 대표적인 서비스가 바로 아마존 웹 서비스(AWS)이다.

이러한 클라우드 인프라는 사용량에 따라 비용이 청구된다. 서비스의 상황에 따라 유연하게 변경될 수 있다.

이를 이용해 간단하게 인프라를 구축할 수 있다.

사용량 증가에 따른 성능 및 가용성을 높이는 방법으로는 크게 두 가지가 있다. 스케일 업, 스케일 아웃.

스케일 업은 기존 시스템의 물리적 용량을 증가시켜 성능을 높이는 방법이다. 

스케일 아웃은 기존 시스템과 용량이 같은 다수의 장비를 병행 추가하여 가용성을 높이는 방법이다.

이중 좀 더 유연한 방법은 스케일 아웃이다. 이벤트 기간동안에 트래픽이 증가하는 서비스가 있을 것이고 그렇지 않은 서비스가 있을 것이다.

이를 적절히 활용할 수 있는 방법은 하나의 덩어리로 묶여있는 애플리케이션을 여러개의 애플리케이션으로 분리하는 것이다.

## 모노리스와 마이크로서비스

모노리스는 전통적인 시스템의 구조로 하나로 묶여 개발되는 애플리케이션이다. 보통 이를 사용자 인터페이스와 데이터베이스, 서버쪽 애플리케이션 3개의 부분으로 구성된다.

서버쪽 애플리케이션은 논리적인 단일체로 아무리 작은 변화라도 전체를 빌드해서 배포해야한다. 그리고 일체식 애플리케이션은 단일 프로세스에서 실행되기 때문에 확장이 필요할 경우 특정 기능만 확장할 수 없고 전체 애플리케이션을 동시에 확장해야한다. 보통 밸런서를 앞에 두고 여러 인스턴스 위에 큰 덩어리를 복제해 수평으로 확장하는 방식을 사용한다.

작은 변화가 일어났을 때는 이 모든 시스템을 다시 빌드하고 배포해야한다는 문제가 있다.

마이크로서비스는 서버측이 여러 개의 조각으로 구성되어있어 각 서비스가 별개의 인스턴스로 로딩된다. 만약 특정 서비스를 확장하고 싶다면 그 서비스만 스케일 아웃하면 된다.

## 인프라 구성요소

인프라란 엔터프라이즈 IT환경을 운영하고 관리하는데 필요한 근간이되는 하드웨어, 소프트웨어, 네트워킹, 운영체제, 데이터베이스 등을 포괄하는 단어이다.

예전에는 오랜 시간과 비용을 동원해 구축했던 인프라이지만 이제는 여러 IaaS, PaaS서비스를 통해 쉽고 편하게 이용할 수 있다.

현재 상황에서는 기존의 물리적 장비를 구매해서 구축하느냐 혹은 가상화 기술을 이용해 구축하느냐이다.

가상 환경 기술로는 도커가 가장 유명하다.

이렇게 컨테이너 기술을 선택했다면 또 다른 고민거리가 생긴다.

만약 컨테이너가 많아지면 컨테이너의 배치, 복제, 장애복구 등 컨테이너 관리를 위한 기능이 필요해진다.

이러한 기술을 컨테이너 오케스트레이션이라고 한다.

개발 공부를 하다보면 쿠버네티스라는 이름을 한 번쯤은 들어봤을 것이다. 이 것이 바로 컨테이너 오케스트레이션 툴이다.

## 스프링 클라우드

스프링 클라우드는 스프링 프레임워크를 개발하고 있는 피보탈에서 넷플릭스가 공개한 줄, 유레카등의 넷플릭스 오픈 소스를 스프링 부트 프레임워크 기반으로 쉽게 사용할 수 있도록 통합한 것이다.

## 레지스트리

프론트 엔드 클라이언트가 여러 개의 백엔드 서비스를 어떻게 호출해야할까?

이를 위한 패턴이 바로 디스커버리 패턴이다. 클라이언트가 여러 개의 마이크로서비스를 호출하기 위해서는 최적 경로를 찾아주는 라우팅 기능과 로드밸런싱 기능이 필요하게 되는데 라우팅 기능을 줄이 담당하고 로드밸런싱은 리본이 담당한다.

라우팅이 제 역할을 하기 위해서는 서비스 명칭에 해당하는 IP주소를 알아야한다. 그러나 클라우드 환경에서 동적으로 변경되는 백엔드의 유동 IP정보를 매번 전송받아 변경하기보다 특정 공간에서 이러한 정보를 관리하는 것이 좋다.

이를 넷플릭스 OSS의 유레카가 담당하고 이러한 패턴을 서비스 레지스트리 패턴이라한다.

서비스 인스턴스가 로딩될 때 자신의 서비스 이름과 할당된 IP주소를 레지스트리 서비스에 등록한다. 그 다음 클라이언트가 해당 서비스를 호출할 때 라우터가 레지스트리 서비스를 검색해 해당 서비스의 이름과 등록된 IP주소를 확인한 후 호출한다.

<img width="455" alt="스크린샷 2024-05-11 시간: 23 59 32" src="https://github.com/jh10253267/TIL/assets/108499717/7095caf5-821c-4976-99f3-c2f652135648">
