# Redis

## 개요

DB 접속 비용은 매우 비싸다.

이러한 반복되는 호출정보를 캐싱해서 저장해서 매 요청마다 DB에 접속을 맺는게 아니라 캐싱된 정보를 사용한다면 어떨까?

## 캐싱 방법

### Redis VS Local Caching

DB에선 질의를 해서 가져오지만 캐싱에서는 키를 이용해서 값을 가져온다.

캐싱을 사용하는 방법은 크게 두 가지가 있는데 Redis와 Local Caching이 있다.

우선 로컬 캐싱은 서버 내에 캐싱하는 방법으로 서버와 라이프사이클을 함께할 수 있고 네트워크를 타지 않기 때문에 Redis에 비해 빠르다는 장점이 있다.

그러나 이러한 구조는 장점이자 단점이 되는데 그 이유는 여러대의 서버를 이용해서 서비스를 할 때 처음 요청이 A서버로 가고 두번째 요청이 B서버로 가게되면 기존에 캐싱된 데이터를 새롭게 캐싱을 해야하는 문제가 발생하고 캐시는 임시적인 데이터로 캐싱된 데이터가 변한다면 그 데이터도 새롭게 캐싱이되어야한다.

 만약 데이터가 삭제된다면 캐시역시 삭제되어야한다. A서버와 B서버에 insert요청이 접수되었고 삭제 요청은 B서버에만 간다면 상태가 맞지 않게된다.

Redis는 인메모리 데이터베이스로 다양한 command를 제공하고있고 단일 스레드로 구성된다.

여러 인스턴스가 하나의 데이터를 공유할 수 있다는 장점이 있고 로컬 캐싱보다 느리다는 단점이 있다. 그래도 일반적인 MySQL보다는 빠르다.

## Redis 구조

Redis는 크게 4가지 구조로 구분할 수 있다.

1. Stand Alone
2. Master-Replica
3. Sentinel
4. Cluster

Stand Alnone은 한 대의 인스턴스로 구성하는 방법이고 Master-Replica는 Master의 싱크를 Replica가 따라가는 방법이다.

Sentinel은 일반적인 Master-Replica 구조에서 Master가 내려가면 별다른 조치를 취하지 않지만 Sentinel의 경우 Master가 내려간 경우 Replica가 Master로 전환되고 그 시간동안 Master가 복구시키고 이 것을 Replica로 전환시킨다.

Cluster는 Master-Replica가 여러대가 있는 구조로 Master에 장애가 생긴 경우 Replica가 자동으로 Master로 전환되며 샤딩이라고 하는 분할이 일어난다.

## Redis VS MemCached
일반적으로 Redissms MemCached의 기능의 대부분을 포함하고 있다.

## Redis의 특징

인메모리라는 뜻은 휘발성이라는 의미이다.  
사실 캐싱된 데이터는 원본이 있는 데이터라서 큰 문제는 없겠지만 캐싱하여 관리하는 데이터가 많을 경우에 한 번에 다시 불러와 캐싱을 한다면 순간적으로 DB I/O가 증가할 수 있는 문제가 있다.

Redis의 속도가 빠르기때문에 Redis를 메인으로 사용하는 경우도 있다고 한다. 그러나 이런 경우 데이터 유실문제가 있기 때문에 Sentinel구조를 사용해서 여러개의 Redis인스턴스를 구성하고 이를 하나처럼 사용하는 것이다. 

Redis의 장점중에 하나가 다양한 command를 지원한다는 것인데 이는 공식 사이트에가면 볼 수 있다.

## Redis Template

위에서 말한 대로 Redis에서는 다양한 command를 제공한다. 이를 쉽게 사용하기 위한 것이 바로 Redis Template인데 여기서 명령을 내리면 Redis서버로 날아가게된다.

## 유의점

* 캐싱된 데이터는 원본DB에서 가져오는 것이다. 그렇기 때문에 자주 변경되는 데이터의 경우엔 변경될 때마다 DB에서 새롭게 받아와서 캐싱을 해야하기에 변경이 잦은 데이터를 캐싱하는 것은 의미가 없다.

* 자주사용하는 데이터를 캐싱하면 좋다. 사용이 많은 데이터를 캐싱할 수록 DB에 가해지는 부하가 적어지기 때문이다.

## 사용법

1. MvnRepository에서 Redis의존성을 추가해준다.
2. RedisConfig클래스를 작성해준다.
3. 
