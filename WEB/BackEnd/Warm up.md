# Warm Up

## 개요

스프링 부트 프로젝트를 진행하면서 성능 개선을 하려했다.  
처음 애플리케이션을 실행시키고 성능을 측정하는데 이상하게 요청을 보내면 보낼수록 점점 응답이 빨라지는 것을 발견했고 의아했다.

이러한 현상의 구체적인 이유를 알아보자.

## 자바의 특성

작성된 자바 코드는 1차적으로 Byte Code로 컴파일된다.  
이 파일은 jar, war파일로 아카이빙된다.

이 파일을 실행하면 JVM은 이를 기계 언어로 번역하여 CPU에서 처리하는 과정을 거친다.

이렇게 자바는 컴파일과 인터프리트 스텝을 거쳐서 실행되는 언어이다.

이러다보니 컴파일과정에서 바로 기계어로 변환되는 컴파일 언어에 비해 성능이 낮다고 볼 수 있다.

컴파일 과정을 거치며 코드 최적화도 수행하기에 일반적으로 인터프리터 언어보다 좋은 성능을 기대할 수 있다.

그러나 이는 컴파일 언어의 장점이자 단점이라고 볼 수 있다. 왜냐하면 이렇게 컴파일된 언어는 빌드된 해당 CPU 아키텍쳐에 종속적이기 때문에 만약 다른 CPU아키텍쳐에서 실행하고싶다면 다시 빌드 과정을 거쳐야한다.

아무튼 이러한 성능 차이때문에 JIT Compiler를 도입했다.

JIT Compiler는 바이트 코드를 기계어로 변환시킬 때 기계어를 캐싱해서 재사용하게 된다. 이를 통해 반복되는 기계어 변환 과정을 줄일 수 있고 런타임 환경에 맞추어 최적화를 시켜 성능 향상을 이룰 수 있다.

즉, 런타임 시점에 바이트 코드를 기계어로 동적으로 번역한다.

조금 더 자세히 알아보자.

JIT 컴파일러는 애플리케이션에서 자주 실행된다고 판단되는 부분만 기계어로 컴파일한다. 이 부분을 핫스팟이라고 한다. 또한 JIT는 실행중인 애플리케이션의 동작을 분석하고 코드 실행 횟수, 메소드 호출 등의 정보를 측정하고 기록한다. 이를 프로파일링이라고 한다. JIT 컴파일러는 프로파일링 결과를 토대로 핫스팟을 식별한다. 그런 뒤 메소드 단위로 바이트코드를 기계어로 번역한다.

이렇게 번역된 기계어를 코드 캐시라는 공간에 저장한다. 저장해놓으면 핫스팟으로 판단된 코드는 다시 컴파일하지 않고 캐싱된 정보를 사용할 수 있다.

그러나 이러한 대안은 자바 성능 향상에는 도움이 되지만 애플리케이션이 처음 실행될 시점에서는 캐싱되어있는 정보가 없다보니 성능 이슈가 발생할 수 있다.

그래서 어플리케이션 시작 후 의도적으로 미리 로직을 수행하여 기계어가 캐싱되고 최적화 될 수 있도록 하는 웜업 절차가 필요하다.


하나의 이유가 더 있다. 바로 클래스로더다.

JVM에서 자바의 클래스를 읽어오기 위해 클래스로더가 사용된다. 이는 클래스파일을 찾고 메모리에 로드해 실행 가능한 상태로 만드는 역할을 한다.

1. Class Loading : 클래스 파일을 가져와 JVM 메모리에 적재한다.
2. Class Linking : 클래스가 참조하는 다른 클래스, 메소드, 필드등을 확인하고 필요하면 메모리 상에 연결한다.
3. Class Initialization : 클래스 변수를 초기화하거나 static 블록 내의 코드를 실행하는 등 초기화 작업을 한다.

문제는 클래스 로더가 지연 로딩 방식으로 동작한다는 것이다.

클래스 로더는 최초로 클래스가 필요해진 시점에 클래스를 로드한다.

애플리케이션이 배포된 직후에는 대부분의 클래스들이 한번도 사용되지 않은 상태이다. 따라서 클래스 로더가 메모리에 적재하지 않은 상태이다. 이런 상황에서 요청이 들어오면 그 때에서야 클래스 로더가 클래스를 메모리에 적재하게 되기 때문이다.








