# JWT 인증

## 개요
API서버란 화면을 제공하지 않고 필요한 데이터만 제공하는 서버를 말한다.
이와 같은 방식을 CSR 즉, 클라이언트 사이드 렌더링이라 한다.<br>

이 때 서버와 통신하는 URL을 외부에서 알게되면 문제가 생기게 된다. <br>

일반적으로 CORS는 브라우저에서 적용되는 개념으로 포스트맨과 같은 툴을 이용하면 얼마든지 요청을 보내고 응답을 받을 수 있다.

그렇기 때문에 API서버에서는 다양한 방법으로 특정한 사용자나 프로그램에서만 API를 호출할 수 있도록 제한해야한다.

## 토큰 기반의 인증

초창기 API서버는 API 서버를 호출하는 프로그램의 IP주소를 확인하는 방법으로 외부로 부터의 무분별한 호출을 막았다.<br>

호출하는 쪽의 IP와 서버 내부에 보관된 IP를 비교하여 허용된 IP에서만 API서버에서 결과를 만들어 주는 식이었다.<br>

그리고 이와 함께 정해진 키값을 이용하는 것이 일반적인 방법이다.

최근에는 토큰을 이용하곤 하는데 API를 이용하고자 하는 사람들은 서버에서 토큰을 받아 보관하고 호출할 때 자신이 보관하고 있는 토큰을 같이 전달하여 서버에서 이를 확인하는 방식이다.

이런 방식은 놀이공원 입장권에 비유할 수 있다.

 일단 입장권을 가지고 있어야 입장이 가능하다.(인증)

그리고 티켓의 종류에 따라서 이용할 수 있는 놀이시설이 다르다.

프리패스, 놀이기구 5개 탑승가능 티켓, 동물원 티켓.(인가)

## Access Token & Refresh Token

입장권에 해당하는 토큰을 API서버에서는 Access Token이라 한다. 이는 특정 자원에 접근할 권한이 있는지 확인하기 위한 수단이다. 그래서 외부에서 API서버를 호출할 때 토큰을 함께 전달하면 이를 이용해서 검증하고 그 결과에 따라서 요청을 처리한다.

Access Token을 이용한 기본적인 인증 시나리오는 다음과 같다.

* 사용자가 API서버를 호출할 때 Access Token을 같이 전달한다.
* API서버는 해당 토큰을 검사하고 유효기간이 남아있다면 문제없이 작업이 처리된다.

그러나 만약 이 Access Token을 악의적인 목적을 가진 사용자에게 탈취당한다면 문제가 생긴다. 악의적인 사용자가 마치 토큰을 발급받은 본인인것처럼 가장해 악의적인 행위가 가능하기 때문이다.

그렇기 때문에 이 토큰의 유효기간을 최대한 짧게 지정하여 짧은 시간동안에만 토큰을 사용할 수 있도록 처리해야하고 Access Token을 발급받을 수 있는 Refresh Token을 생성해주어 필요할 때 다시 발급받을 수 있게 한다.

Access Token과 Refresh Token을 이용한 시나리오는 이렇다.

* 사용자가 Access Token을 전달한다.
* API서버에서 Access Token을 검증한다.
* 만약 유효기간이 지난 토큰일 경우에 사용자에게 만료된 토큰임을 알려준다.
* 사용자는 Refresh토큰을 전송해서 새로운 Access Token을 요구한다.
* 만약 Refresh Token에 문제가 없다면 새로운 Access Token을 생성해서 전달한다.
* 만약 Refresh Token이 거의 만료된 상황이라면 새로운 Refresh Token을 같이 전송한다.

그러나 만약 이 토큰 둘 다 탈취당하는 경우는 어떻게 해아할까?

우리가 다른 컴퓨터나 해외에서 내 계정에 접속하면 메일이나 휴대폰 알림이 발송되는 것을 자주 봐왔을 것이다.
이는 원래의 사용자에게 활동 여부를 알려주거나 특정한 IP에서만 사용할 수 있도록 하는 현실적인 해결책이다.

그러나 이런 방식도 한계가 있는데 이는 JWT토큰이 단순한 문자열이라는 것이다.

예를 들어 공격자가 refresh token을 탈취한 상황이라면 얼마든지 새로운 access token을 발급받을 수 있다.

이런 문제점을 보완하고자 토큰을 데이터베이스에 넣어두고 토큰을 갱신할 때 데이터베이스의 값과 비교하는 방법을 이용할 수 있다. 이런 경우 정상적인 사용자가 refresh token을 새롭게 갱신하면 공격자가 탈취한 refresh token이 쓸모없게 된다.

## JWT의 구성

JWT는 인코딩된 문자열로 크게 헤더, 페이로드, 서명 부분으로 작성되어있다. 헤더는 메타 정보를 나타낸다. 어떤 알고리즘을 사용했고 어떤 방식의 토큰인지 등등.

페이로드는 클레임이라고 부르는 키와 값으로 구성된 정보들을 제공한다.

예를 들어
"name" : "junhyeok",
"email" : "junhyeok@example.com"
와 같이 json 형식의 정보들이다.

jwt.io에선 별다른 절차 없이 jwt토큰을 파싱하여 볼 수 있다.

만약 사이트를 돌아다니면서 쿠키값에 토큰이 들어가있는 것을 본다면 jwt.io 사이트에서 직접 파싱해서 내가 현재 이용하는 웹 서비스에서는 나의 어떤 정보들을 저장해서 사용하고 있는지를 확인해볼 수 있다.

예를 들어 스파르타 코딩클럽 사이트에 가서 개발자도구를 열어서 살펴보면 쿠키에 토큰을 저장하고 있는 것을 확인해볼 수 있다.  
간단하게 확인해보려면 이 사이트를 방문하여 확인해볼 수 있다.

그럼 쉽게 정보를 누구나 볼 수 있으면 이게 어떻게 보안 토큰이 될 수 있는지 의아할 수 있다. 바로 마지막 서명 부분이다.

jwt토큰을 사용한 인증/인가를 실습할 때 JwtUtil에 jwt.key값을 넣어줬다. 이 값은 서명에 쓰인다.

```java
Jwts.builder()
.signWith(SignatureAlgorithm.HS256, key.getBytes())
```

이렇게 서명 부분을 설정해주고 만약 사용자의 요청이 들어왔는데 서명부분이 일치하지 않는다면 변조된 토큰인 것이다.

```java
Jwts.parser()
   .setSigningKey(key.getBytes())
```

그럼 SignatureException예외를 발생시킨다.

이렇게 보안 토큰으로써 기능한다.

## 로그아웃 구현

jwt는 사용자 측에서만 보관하는 값이기 때문에 로그아웃의 개념이 없다.

어떻게 하면 로그아웃을 구현할 수 있을까?

서버에서 사용자의 토큰 정보를 저장하고 있다면 가능하다.

예를 들어 토큰을 발급해주고 그 것을 DB에 저장하고 사용자의 토큰이 서버로 전달되었을 때 DB와 대조하여 확인하는 로직을 작성한다.  
그리고 만약 로그아웃을 요청한다면 사용자의 토큰 정보를 삭제하는 식으로 로그아웃을 구현할 수 있다.

토큰 정보를 Redis에 저장하여 사용하여도 무방하다.

이 경우, 로그아웃 요청을 받을 시 사용자의 캐시 정보를 삭제하는 식으로 구현할 수 있다.

## 총정리

1. 토큰을 생성하는 api를 호출해 서버에서 발행한 access token과 refresh token을 발급받는다. 브라우저는 이 토큰들을 저장해두고 필요할 때마다 토큰들을 찾아서 사용하도록한다.
2. 브라우저에서 api경로를 호출할 때 가지고있는 access token을 같이 전달한다.
3. access token의 유효기간이 만료되면 서버에서 에러메시지를 전송하게되는데 이 메세지를 판단해서 브라우저는 refresh token으로 새로운 access token을 받고 원래 의도했던 작업이 수행되어야한다.
(이 과정은 사용자가 참여하지 않고 자동으로 처리되어야하기에 slient refreshing이라고 부르기도한다.)
4. refresh token이 만료되었을 경우에는 사용자에게 다시 1단계부터 시작해야함을 알려주어야한다.
