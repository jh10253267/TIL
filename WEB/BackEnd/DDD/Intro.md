# DDD

## 개요

도메인에 대해 처음 들었을 땐 우리가 프로그램을 작성할 때 게시글, 댓글, 좋아요등의 기능들과 패키지를 나누어 관리하는 개념이라고만 생각했다.

지금까지 공부해본 느낌으론 코드 외적인 부분의 뉘앙스가 느껴진다. TDD와 같은 느낌의 이론이 아니라 애자일과 xp와 같은 느낌이 들었다.

> 의뢰인과 개발자 모두가 만족할만한 결과물을 내기위한 방법.

출처 : 도메인 주도 개발 시작하기 - 최범균, 한빛미디어

## 도메인이란?

온라인 서점을 이용하는 경우를 생각해보자 어떤 책이 나왔는지 검색하고 목차와 서평을 보면서 이 책은 어떤 책일지 가늠해본다. 읽고싶은 책이 있다면 장바구니에 담아두기도하고
구매할 때도 있다.

이런 서비스를 구현한다고 생각해보자. 가장 큰 단위는 온라인 서점이다.
그리고 온라인 서점 서비스는 책을 판매하는데 필요한 상품 조회, 구매, 결제, 배송 추적 등의 기능을 제공해야한다.
이 때 온라인 서점은 소프트웨어로 해결하고자 하는 문제영역 즉 도메인에 해당한다.

한 도메인은 다시 하위 도메인으로 나눌 수 있다.

카탈로그 하위 도메인은 고객에게 구매할 수 있는 상품 목록을 제공하고 주문 하위 도메인은 고객의 주문을 처리하는 등이다.

우리가 개발하는 기능들의 영역에는 전문가들이 있다. 이들은 해당 도메인에 대한 지식과 경험을 바탕으로 본인들이 원하는 기능 개발을 요구한다.

## 도메인 모델

도메인 모델은 특정 도메인을 개념적으로 표현한 것이다. 

주문 도메인을 예로 들면 어떤 상품을 주문하려면 상품과 상품 갯수를 선택한다. 그리고 배송지를 입력하고 총 지불 금액을 계산하고 결제수단을 선택하는 등.

이를 자바의 객체로 나타내는 식이다.

## 도메인 모델 패턴

일반적인 애플리케이션의 아키텍쳐는 다음과 같이 구성된다.

* UI - 사용자의 요청을 처리하고 사용자에게 정보를 보여준다.
* 응용 - 사용자가 요청한 기능을 실행한다.
* 도메인 - 시스템이 제공할 도메인 규칙을 구현한다.
* 인프라스트럭쳐 - 데이터베이스와 같은 외부 시스템과의 연동을 처리한다.

도메인 계층은 도메인의 핵심규칙을 구현한다. 주문 도메인의 경우 출고 전에 배송지를 변경할 수 있다는 규칙과 주문 취소는 배송 전에만 할 수 있다는 규칙을 구현한 코드가 도메인 계층에 위치하게된다. 이런 도메인 규칙을 객체 지향 기법으로 구현하는 패턴이 도메인 모델 패턴이다.

도메인의 규칙을 정의하고 구현한다.

## 엔티티와 벨류

도출된 모델은 엔티티와 벨류로 구분할 수 있는데 엔티티란 식별자를 갖는 클래스를 말하고 벨류는 개념적으로 완전한 하나를 표현할 때 사용한다.

벨류 타입의 장점은 벨류 타입을 위한 기능을 추가할 수 있다는 점이다. 예를 들어 Money라는 타입은 돈 계산을 위한 기능을 추가할 수 있다.

```java
public class Money {
  private int value;
  public Money add(Money money) {
    return new Money(this.value + money.value);
  }
  ...
}
```

다소 특이한 것은 어떤 객체 내부에서 돈이라는 값을 사용할 경우 해당 객체의 필드로 int money와 같이 사용하는 경우가 많은데 그 의미를 명확하게 표현하기 위해 위와 같이 작성할 수 있는 것이다.

이렇게 해서 Money를 사용하는 코드는 정수 타입 연산이 아닌 돈 계산이라는 의미를 가진다.

이렇게 변경할 경우 코드의 의미를 이해하기 쉽게 한다.

위의 코드를 보면 기존 데이터를 변경하는 코드가 없다. 예를 들면 this.value = money.value와 같이 사용하지 않고있다.

이와 같은 타입을 불변이라고 한다.

벨류 타입을 불변으로 구현하는 여러가지 이유가 있는데 가장 중요한 이유는 안전한 코드를 작성할 수 있다는 점에 있다.

책에서 나온 예시코드를 보면
```java
Money price = ...;
OrderLine line = new OrderLine(price, price, quantity);
```

여기서 price.setValue(0)과 같이 변경할 수 있다면 원래 의도와는 다르게 price의 값이 잘못 반영되는 상황이 발생할 수 있게된다.

따라서 이와같은 문제를 방지하려면 OrderLine의 생성자는 새로운 Money객체를 생성하도록 코드를 작성해야한다.

```java
public class OrderLine {
  ...
  private Money money;
  public OrderLine(Product product, Money price, int quntity){ 
    ...
    this.price = new Money(price.getValue());
    ...
  }
}
```

반면 Money를 불변으로 생성한다면 파라미터로 전달받은 price를 안전하게 사용할 수 있다.

엔티티 식별자의 실제 데이터는 String과 같은 문자열로 구성된 경우가 많다. 신용카드 번호도 16자로 구성된 문자열이고 이메일도 문자열이다.

이러한 식별자는 해당 도메인에서 특별한 의미를 가지기 때문에 식별자를 위한 벨류 타입을 사용해서 의미를 가지도록 할 수 있다.

예를 들어  
```java
public class Order {
  private String orderNo;
  public String getOrderNo(){
    return orderNo;
  }
}
```
이렇게 하는 것이 아니라 

```java
public class Order {
  private OrderNo id;
  public OrderNo getId(){
    return id;
  }
}
```

이렇게 하면 타입 자체로 의미를 나타낼 수 있다.

## 아키텍쳐

전형적인 웹 구조를 네 가지 계층으로 나눌 수 있다.

* 표현계층
* 응용계층
* 도메인 계층
* 인프라스트럭쳐 계층

표현 영역은 사용자의 요청을 받아 응용영역에 전달하고 처리 결과를 다시 사용자에게 보여주는 역할을 한다. 스프링 MVC프레임워크가 표현 영역을 위한 기술에 해당한다.

응용 영역은 시스템이 사용자에게 제공해야할 기능을 구현한다. 응용영역은 기능을 구현하기 위해 도메인 영역의 도메인 모델을 사용한다.

따라서 로직을 직접 수행하기 보다는 도메인 모델에 로직 수행을 위임한다.

```java
public class CancelOrderService {
  @Transactional
  public void cancelOrder(String orderId) {
    Order order = findOrderById(orderId);
    if(order == null) throw new OrderNotFoundException(orderId);
    order.cancel();
  } 
}
```

응용 영역은 이러한 도메인 모델을 이용해서 사용자에게 제공할 기능을 구현한다.

도메인 영역에서는 도메인 모델을 구현한다. 이는 도메인의 핵심 로직을 구현한다.
예를 들어 배송지 변경, 결제 완료 등이 있다.

인프라스트럭처 영역은 구현 기술에 관한 영역으로 DB와의 연동을 처리하거나 메세징 큐를 사용하거나 HTTP Client를 이용해서 다른 REST API를 호출하는 등의 역할을 한다.

그 외의 영역에서는 구현 기술을 사용한 코드를 직접 만들지 않고 인프라스트럭처 영역에서 제공되는 기능을 사용해서 필요한 기능을 개발한다.

DB 연결이 필요하다면 인프라스트럭처 영역의 DB 모듈을 사용해서 데이터를 읽어오는 식이다.

## 계층 구조 아키텍처

네 영역을 구성할 때 많이 사용하는 아키텍처가 있다. 표현 영역은 응용 영역을 사용하고 응용 영역은 도메인, 도메인 영역은 인프라스트럭처 영역을 사용한다.

그 의존 방향은 한 방향으로 상위 계층에서 하위 계층으로의 의존만 존재하고 그 반대는 허용되지 않는다.

다만 구현의 편리함을 위해 계층 구조를 유연하게 하여 응용 계층이 인프라 스트럭쳐처에 의존하기도 한다.

그러나 몇 가지 단점이 있다.

바로 상위 계층이 인프라스트럭처영역에 종속된다는 점이다.

이렇게 종속되는 경우 상위 계층만 테스트하기 어렵다는 문제와, 구현 방식을 변경하기 어렵다는 문제가 있다.

이에 대한 해답이 DIP이다.

예를 들어 가격 할인 계산을 하려면 고객 정보를 구하고 룰을 이용해서 할인 금액을 구해야한다.

가격 할인 계산을 하는 모듈을 CalculateDiscountService라고 해보면 이는 고수준 모듈에 해당한다.

그리고 고객 정보를 구하는데엔 JPA를 사용하고 할인 금액을 구하는데엔 Drools로 룰을 적용한다.

이처럼 고수준 모듈이 저수준 모듈에 의존하고 있는 구조를 DIP를 이용하여 저수준 모듈이 고수준 모듈에 의존하도록 바꿀 수 있다.

고수준 모듈인 Service의 입장에서 봤을 때 룰 적용을 어떻게 했는지는 중요하지 않다. 고객 정보와 구매정보에 룰을 적용하여 할인 금액을 구한다는 것이 중요할 뿐이다.

따라서 이를 추상화하여 인터페이스로 나타낼 수 있다.

```java
public interface RuleDiscounter {
  Money applyRules(Customer customer, List<OrderLine> orderLines)
}
```

```java
public class CalculateDiscountService {
  private RuleDiscounter ruleDiscounter;

  public CalculateDiscountService(RuleDiscounter ruleDiscounter) {
    this.ruleDiscounter = ruleDiscounter;
  }

  public Money calculateDiscount(List<OrderLine> orderLines, string customerId) {
    Customer customer = findCustomer(customerId);
    return ruleDiscounter.applyRules(customer, orderLines);
  }
}
```

이렇게 변경한 코드에는 Drools에 의존하는 코드는 없고 RuleDiscounter가 룰을 적용한다는 것만 알 수 있다.

이렇게 수정한다면 고수준 모듈인 CalculateDiscountServicer가 더 이상 구현 기술에 의존하지 않고 RuleDiscounter를 구현한 구현체가 인터페이스 RuleDiscounter를 바라본다. 이렇게 저수준 모듈이 고수준 모듈에 의존하는 관계가 만들어지고 이를 DIP라고 한다.

만약 구현 기술을 변경한다고 해보면 고수준 모듈인 CalculateDiscountService는 변경할 필요가 없어진다.

이를 통해 구현 교체가 어렵다는 문제와 테스트가 어려운 문제를 해결할 수 있게되었다.

주의해야할 점은 저수준 모듈의 관점에서 초상화를 하는 것이 아니라 고수준 모듈의 기준에서 추상화를 해야한다는 점이다.

위와 같은 경우 저수준 모듈의 관점에서 RuleEngine과 같이 추상화를 한다고 하면 여전히 고수준 모듈이 저수준 모듈에 의존하는 것이 된다. 중요한 것은 할인 금액을 규칙에 따라 계산한다는 것이며 할인 금액을 구하기 위해 RuleEngine을 사용한다는 것은 중요하지 않다. 이처럼 수상화한 인터페이스는 저수준 모듈이 아닌 고수준 모듈에 위치해야한다.

## 도메인 영역의 구성요소

1. 엔티티
2. 벨류
3. 애그리거트
4. 리포지터리
5. 도메인 서비스

도메인 모델과 DB 테이블의 엔티티의 차이는 도메인 모델이 데이터와 도메인 기능을 함께 제공한다는 것이다.

예를 들어 도서 대출을 표현하는 엔티티는 대출과 관련된 데이터뿐만 아니라 대출처리를 위한 기능을 함께 제공한다.

```java
@Entity
@Table(name = "rental")
public class Rental {
...
  public Rental rentBook(Long bookId, String title) {
      this.addRentedItem(RentedItem.createRentedItem(bookId, title, LocalDate.now()));
      return this;
  }
}
```
이런식으로 도메인 관점에서 기능을 구현하고 기능 구현을 캡슐화 해서 데이터가 임의로 변경되는 것을 막는다.

도메인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현할 수 있는데 주문자를 표현하는 경우 벨류타입으로 주문자 이름과 이메일 데이터 등을 포함할 수 있다.

이럴 경우 별도의 테이블로 분리해서 저장해야한다.

도메인이 커질수록 개발할 도메인 모델이 커지면서 많은 엔티티와 벨류가 생긴다. 이렇게 복잡해진 모델을 다시 그룹화 하여 묶은 것이 바로 애그리거트이다.

예를 들어 주문이라는 도메인 개념은 주문, 배송지 정보, 주문자, 주문 목록, 총 결제 금액의 하위 모델로 구성되는데 이를 하나로 묶어 주문이라는 상위 개념으로 표현할 수 있다.