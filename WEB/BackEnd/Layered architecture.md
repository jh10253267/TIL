# 3-Layered Architecture

## 개요

아키텍처는 여러가지가 존재한다. 그 중 대표적인 아키텍처가 바로 3-Layered Architecture이다.

웹개발을 하다보면 중복되는 부분이 있을 것이다.<br>
예를 들어 어떤 사이트에선 메인에서도 메일이 얼마나 쌓였는지 보여지고 다른 페이지로 이동해도 보여진다.<br>
이런 경우에 각 컨트롤러들은 중복된 로직을 가지게 될 것이다.<br><br>
중복되고 반복되는 코드는 개발자를 불안하게 한다.<br><br>

Q) 이런 중복되는 부분들을 처리하려면?<br><br>
A) 비즈니스 메소드를 별도의 Service객체에서 구현하고 컨트롤러는 Service객체를 사용한다.

![이미지](https://cphinf.pstatic.net/mooc/20180219_85/1519008848012uvMNx_PNG/1.png?type=w760)

서비스 객체라는 비즈니스 로직 : DAO와 컨트롤러와는 다른 비즈니스 로직들이 존재하는 계층을 서비스 계층이라고 부른다.
보통 하나의 비즈니스 로직은 하나의 트랜잭션으로 동작한다.<br>

중복되는 코드는 데이터 엑세스 메소드를 별도의 Repository(DAO)객체에서 구현하도록하고 Service는 Repository객체를 사용한다.

## 아키텍처 개요

로버트 C 마틴은 클린 아키텍처에서 소프트웨어의 가치는 행위 가치와 구조 가치로 나누괴 소프트웨어를 부드럽게 만드는 것이 구조가치라고 했다. 행위 가치란 소프트웨어의 기능을 말하고 구조 가치는 아키텍처를 말한다.

토끼와 거북이 경주를 예로들면 가장 빨리 가는 것은 제대로 가는 것이고 코드의 설계와 구조를 깔끔하게 만들려고 노력하지 않고 기능 구현만 목표로 삼으면 소프트웨어가 엉망이 된 상황에 대처하는 데에 더 많은 비용이 든다고 말한다.

비즈니스 로직이란 시스템의 목적인 비즈니스 영역의 업무 규칙, 흐름, 개념을 표현하는 용어이다. 개발자는 문제 영역의 비즈니스 로직을 분석하고 프로그래밍 언어로 잘 표현하는 것이다.

이는 기능이 잘 동작하는 것과 이해하기 쉽고 변경이 쉬운 시스템을 만드는 것을 의미한다.

설계 원칙중 핵심은 관심사의 분리로 이를 통해 시스템을 이해하기 쉽게하고 변경하기 쉽게 만든다.

하지만 실제로는 잘 지켜지지 않고있다고 말한다.

예를 들어, 비즈니스 로직을 처리하는 코드는 몇 줄 되지 않지만 SQL문은 수백줄, 수천줄이 되는 경우다.

이럴 경우 담당자가 없어질 경우 문제가 생길 것이고 비즈니스 로직이 모두 SQL에 몰려있게 되고 지속적인 DB성능 저하가 일어난다면 결국 재개발을 해야할 것이다.

이런 이유로 누구나 이해할 수 있고 쉽게 유지보수할 수 있는 시스템이 중요해진다.

### 데이터베이스 중심 아키텍처의 문제

스프링을 이용하여 개발할 경우 컨트롤러, 서비스, 레포지토리, DTO를 메인으로 구성되고 비즈니스 개념과 규칙들은 테이블과 SQL쿼리 묶음에 존재한다. 이러한 구조에서 만약 NoSQL로 교체하기로 결정했을 때 변경하려고 해도 쉽게 변경할 수 없다. DB와 비즈니스 로직이 끈끈하게 결합되어있기 때문이다.

성능도 데이터베이스의 성능에 의존하게된다. 사실상 애플리케이션이 할 일이 없고 데이터가 증가됨에 따라 성능은 지속적으로 떨어지고 이를 최적화하기 위해서 데이터베이스의 사양과 용량을 증가시키고 쿼리 튜닝에 집중할 수밖에 없다. 사실상 정말 바쁜 것은 데이터베이스이기 때문에 스케일아웃을 해봤자 큰 의미가 없다. 

생각해보면 데이터베이스의 본질은 데이터 저장 처리이고 SQL도 데이터 처리를 위한 언어이다.

최신 웹은 클라우드 기반으로 필요한 만큼의 인프라를 유연하게 이용할 수 있고 저장 기술 또한 종류가 다양하다. 그리고 웹, 모바일, IoT 등등 여러 기기의 입출력을 지원해야하고 다양한 저장소와의 연계가 필요하다.

즉, 클라우드 환경에선 애플리케이션의 자체 성능보다 확장성과 유연성이 더 중요해졌다. 이를 위해 강하게 결합되어있던 비즈니스 로직과 데이터를 분리하는 것이 필요해진다.

## 3-Layered Architecture

레이어드 아키텍쳐는 가장 클라이언트와 맞닿아있는 계층부터 프레젠테이션, 비지니스, 데이터 엑세스계층으로 구성된다.

프레젠테이션 층의 관심사는 화면 표현이고 비즈니스 로직 층의 관심사는 비즈니스 정의, 데터 엑세스 층의 관심사는 데이터 처리이다.

레이어드 아키텍처의 장점을 극대화하고 유지보수성을 위해 몇 가지 규칙을 둔다.

* 상위 계층이 하위 계층을 호출하는 단방향성을 가져야한다.
* 상위 계층은 하위의 여러 계층을 알 필요 없이 바로 및의 계층만 사용한다.
* 상위 계층이 하위 계층에 영향을 받지 않게 해야한다.
* 하위 계층은 자신을 사용하는 상위 계층을 알지 못하게 구성해야한다.
* 계층 간의 호출은 인터페이스를 통해 호출하는 것이 바람직하다.(구체화에 의존하지 않게 하여 계층간 약한 결합을 유지하기 위해서다.)

계층간 인터페이스를 사용하는 구조는 상위 계층이 직접 하위 계층을 호출하지 않고 추상적인 인터페이스에 의존하게해서 하위 계층에서는 추상적 인터페이스를 이행하는 여러 구현체를 선택적으로 적용할 수 있다. 이를 DIP라고 한다.

그러나 OCP는 달성하지 못한다. OCP란 개체의 행위는 확장할 수 있어야하지만 이 때 개체를 변경해서는 안된다는 의미를 담고있다.

달성하지 못하는 이유는 각 계층이 각자 자신이 제공하는 기능에 대한 인터페이스를 직접 정의하고 소유하고있기 때문이다.

이런 구조에서는 의존성이 상위 계층에서 하위 계층으로 생기게 된다.

따라서 하위 계층의 유형이 추가되어 확장될 때 닫혀있어야 할 상위 계층이 하위 계층에서 정의한 특성에 영향을 받게 된다.

데이터 엑세스 계층이 변경되었을 때 비즈니스 로직 계층이 변경되지 않아야만 OCP를 달성했다고 할 수 있을 것인데 만약 구현체가 A에서 B로 변경된 경우라면 상위 계층에 영향을 주지 않지만 인터페이스가 변경되면 비즈니스 로직 계층이 데이터 엑세스 계층의 변경에 영향을 받을 수 밖에 없다.

해결 방법으로는 DIP를 적용해서 데이터 엑세스 계층에서 정의한 인터페이스를 비즈니스 계층으로 옮기는 방법을 생각해볼 수 있다.

이렇게 되면 위에서 아래로 흘렀던 의존관계를 역전시키고 고수준 영역이 저수준 영역의 변경에 영향을 받지 않게 될 수 있다.

## 레이어드 아키텍처의 장점.

* 역할과 책임을 기준으로 분리되어 유지보수에 용이하고 중복되는 코드를 줄일 수 있다.
* 스프링에서는 설정파일을 프레젠테이션과 나머지를 분리할 수 있다.

지금은 웹이지만 자바 윈도우 프로그램이 될 수도 있다. 이럴 경우 프로그램을 새로 작성하는 게 아니라 프레젠테이션 계층과 그 나머지를 분리해서 서비스 할 수 있다.<br>

Spring 설정 파일을 프레젠테이션 레이어와 나머지를 분리시킬 수 있다.<br>
web.xml파일에서 프레젠테이션 레이어에 대한 스프링 설정은 DispatcherServlet이 읽도록하고 그 외의 설정은 ContextLoaderListener를 통해서 읽도록 한다.<br>
DispatcherServlet을 경우에 따라서 2개 이상 설정할 수 있는데 이 경우에는 각각의 DispathcerServlet의 ApplicationContext가 각각 독립적이기 때문에 각각의 설정 파일에서 생성한 빈을 서로 사용할 수 없다.<br>

위의 경우와 같이 동시에 필요한 빈은 ContextLoaderListener를 사용함으로써 공통으로 사용하게 할 수 있다<br>

ContextLoaderListener와 DispatcherServlet은 각각 ApplicationContext를 생성하는데, ContextLoaderListener가 생성하는 ApplicationContext가 root컨텍스트가 되고 DispatcherServlet이 생성한 인스턴스는 root컨텍스트를 부모로 하는 자식 컨텍스트가 된다.<br>
참고로, 자식 컨텍스트들은 root컨텍스트의 설정 빈을 사용할 수 있다.